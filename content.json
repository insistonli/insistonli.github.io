{"meta":{"title":"李金朋Blog","subtitle":null,"description":null,"author":"李金朋","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"un11fin11","updated":"un33fin33","comments":false,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"un11fin11","updated":"un33fin33","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"记录 复习 学习 希望能坚持。。。。桃李不言 下自成蹊"},{"title":"书单","date":"un11fin11","updated":"un33fin33","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"un11fin11","updated":"un33fin33","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"un11fin11","updated":"un33fin33","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"un11fin11","updated":"un33fin33","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"un11fin11","updated":"un33fin33","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"事件循环","slug":"事件循环","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/05/18/事件循环/","link":"","permalink":"http://yoursite.com/2020/05/18/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"事件循环 {ignore}[toc] 概念 浏览器、JS、执行引擎的关系 JS：一门计算机语言，提供了表达程序逻辑的语法和实现基本功能的API 浏览器：JS语言的真实运行环境，又称之为JS的宿主环境 JS执行引擎：JS宿主环境（例如浏览器）中的一个功能模块，用于解析并执行JS 它们的关系如下： 进程 和 线程 进程：当一个应用程序运行时，需要使用内存和CPU资源，这些资源需要向操作系统申请。操作系统以进程的方式来分配这些资源，一个进程就代表着一块独立于其他进程的内存空间。一个应用程序要运行，必须至少有一个进程启动。进程的最大特点是独立，一个进程不能随意的访问其他进程的资源。这就保证了多个程序在操作系统上运行互不干扰。 线程：可能要同时执行多个任务，每个任务需要在一个线程上运行，线程与线程之间相对独立，但可以共享应用程序的进程数据。 如何理解JS的单线程 我们之所以称JS为单线程的语言，是因为它的执行引擎只有一个线程，并且不会在执行期间开启新的线程。而并非浏览器是单线程的。 单线程的应用程序具有以下的特点： 易于学习和理解：所有代码都是按照顺序从上到下执行的 易于掌控程序：由于代码都按照顺序执行，不会出现中断，也没有共享资源的争夺问题，极大的降低了开发难度。 更加合理的利用计算机资源：创建新的线程和销毁线程都会耗费额外的CPU和内存资源，没有良好的线程设计，将导致程序运行效率低下。而单线程的应用不受此影响 JS如何处理多任务 任何一个程序在执行期间都可能会开启多个任务，比如： 1). 任务1：程序启动时开始进行一些操作2). 任务2：开启一个计时器，每隔一段时间去做一些事3). 任务3：监听按钮是否被点击，当按钮被点击后，去做一些事 由于JS的执行线程只有一个，因此，它通过异步的方式来解决这些任务 下面是单线程的异步和多线程的对比 多线程： 可以看到，如果以多线程的方式运行，会导致程序代码在某些时候会有重叠执行的情况出现，如果这些代码凑巧在使用共享数据，将难以控制最终的运行结果。 而使用异步的方式就解决了该问题： 可以看出，使用异步之后，所有的JS代码都在单个线程中执行，不会出现多个任务同时执行的情况，自然就不会出现资源争夺的问题。 同步代码 和 异步代码 同步代码：程序启动后，在JS执行线程上立即执行的任务代码 异步代码：收到宿主环境（浏览器）的其它线程通知，即将在JS执行线程上执行的代码，例如计时器回调函数中的代码，事件中的代码。JS中的异步代码往往放到一个函数中，该函数成为异步函数，或者描述为，该函数是异步的 执行栈 为了保证JS代码有序的执行，JS执行引擎使用执行栈来组织JS代码 每当调用一个函数时，都会在执行栈中创建一个执行上下文，上下文中提供了函数执行需要的环境，创建了上下文之后，再执行函数 事件循环事件循环是JS处理异步函数的具体方法 具体的做法是： 执行 执行栈 中的代码 遇到一些特殊代码交给浏览器的其他线程处理 将执行栈中的代码全部执行完毕 从事件队列中取出第一个任务放入执行栈，然后重复第1步 事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种： 宏任务（队列）：macroTask，计时器结束的回调、事件回调、http回调等等绝大部分异步函数进入宏队列 微任务（队列）：microTask，Promise.then, MutationObserver 当执行栈清空时，JS引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/05/18/原型和原型链/","link":"","permalink":"http://yoursite.com/2020/05/18/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型和原型链 所有对象都是通过new 函数创建 所有的函数也是对象 函数中可以有属性 所有对象都是引用类型 原型 prototype所有函数都有一个属性：prototype，称之为函数原型 默认情况下，prototype是一个普通的Object对象 默认情况下，prototype中有一个属性，constructor，它也是一个对象，它指向构造函数本身。 隐式原型 proto所有的对象都有一个属性：__proto__，称之为隐式原型 默认情况下，隐式原型指向创建该对象的函数的原型。 当访问一个对象的成员时： 看该对象自身是否拥有该成员，如果有直接使用 在原型链中依次查找是否拥有该成员，如果有直接使用 猴子补丁：在函数原型中加入成员，以增强起对象的功能，猴子补丁会导致原型污染，使用需谨慎。 原型链特殊点： Function的proto指向自身的prototype Object的prototype的proto指向null 链条的全貌原型和原型链 所有对象都是通过new 函数创建 所有的函数也是对象 函数中可以有属性 所有对象都是引用类型 原型 prototype所有函数都有一个属性：prototype，称之为函数原型 默认情况下，prototype是一个普通的Object对象 默认情况下，prototype中有一个属性，constructor，它也是一个对象，它指向构造函数本身。 隐式原型 proto所有的对象都有一个属性：__proto__，称之为隐式原型 默认情况下，隐式原型指向创建该对象的函数的原型。 当访问一个对象的成员时： 看该对象自身是否拥有该成员，如果有直接使用 在原型链中依次查找是否拥有该成员，如果有直接使用 猴子补丁：在函数原型中加入成员，以增强起对象的功能，猴子补丁会导致原型污染，使用需谨慎。 原型链特殊点： Function的proto指向自身的prototype Object的prototype的proto指向null 链条的全貌","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"e的移动尺寸变化和div移动的尺寸变化","slug":"事件源e和div的尺寸变化","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2020/03/18/事件源e和div的尺寸变化/","link":"","permalink":"http://yoursite.com/2020/03/18/%E4%BA%8B%E4%BB%B6%E6%BA%90e%E5%92%8Cdiv%E7%9A%84%E5%B0%BA%E5%AF%B8%E5%8F%98%E5%8C%96/","excerpt":"关于e.clientX 和 div的clientX等其他属性的变化!遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下","text":"关于e.clientX 和 div的clientX等其他属性的变化!遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下 对于点击事件源e来说 clientX，clientY点击位置距离当前可视区域的x，y坐标 pageX,pageY对于整个页面来说，包括了被卷去的body部分的长度 screenX，screenY点击位置距离当前电脑屏幕边界的x，y坐标 offsetX，offsetY相对于带有定位的父盒子的x，y坐标 对于div来说 ))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"实现不设置宽高的盒子的居中","slug":"实现不设置宽高的盒子的居中","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/03/16/实现不设置宽高的盒子的居中/","link":"","permalink":"http://yoursite.com/2020/03/16/%E5%AE%9E%E7%8E%B0%E4%B8%8D%E8%AE%BE%E7%BD%AE%E5%AE%BD%E9%AB%98%E7%9A%84%E7%9B%92%E5%AD%90%E7%9A%84%E5%B1%85%E4%B8%AD/","excerpt":"CSS3 transform有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现?","text":"CSS3 transform有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现? 用css的transform中的translate可以实现,translate控制移动自身宽度的50%刚好实现垂直水平居中 123456789101112131415161718192021222324252627282930313233&lt;!-- 有两个div div2在div1中要实现垂直水平居中 --&gt;&lt;style&gt; *&#123; margin: 0; padding: 0%; &#125; .div1 &#123; position: relative; width: 500px; height: 500px; background-color: green; &#125; .div2 &#123; position: absolute; max-width: 300px; max-height: 300px; background-color: blue; left: 50%; top: 50%; transform: translate(-50%,-50%) &#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;div class&#x3D;&quot;div1&quot;&gt; &lt;div class&#x3D;&quot;div2&quot;&gt; daskjfhljsadhfkj &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"闭包","slug":"闭包","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2019/09/25/闭包/","link":"","permalink":"http://yoursite.com/2019/09/25/%E9%97%AD%E5%8C%85/","excerpt":"闭包","text":"闭包 闭包就是指由权访问另一个函数作用域中的变量的函数。 创建闭包的常见的方式就是在一个函数内部创建另一个函数 当内部函数被保存到外部时，将会生成闭包；闭包会导致原有 作用链不释放，造成内存泄漏。 内存泄漏可以理解为有用的内存因为原有作用链不释放，导致越来越少，就像是内存泄漏了一样 ​ 12345678910111213141516171819202122function a()&#123; var num &#x3D; 100; function b()&#123; num ++; console.log(num); &#125; return b;&#125; var demo &#x3D; a(); demo(); &#x2F;&#x2F;101 demo(); &#x2F;&#x2F;100 123456789101112131415161718192021222324function a() &#123; function b() &#123; var bbb &#x3D; 234; document.write(aaa); &#125; var aaa &#x3D; 123; return b; &#125; var glob &#x3D; 100; var demo &#x3D; a(); demo(); 1这里有对局部和全局变量有一个模糊的印象 闭包的作用 实现公有变量 eg:函数累加器 可以做缓存 eg:eater 可以实现封装，属性私有化。 eg: Person(); 模块化开发，防止污染全局变量 12345678910111213141516171819202122232425262728293031323334var name &#x3D; &#39;bcd&#39;; var init &#x3D; (function ()&#123; var name &#x3D; &#39;abc&#39;; function callName()&#123; console.log(name); &#125; return function()&#123; callName(); &#125; &#125;()) init(); &#x2F;&#x2F;运行后的结果为 abc &#x2F;&#x2F;这就是用闭包实现变量的私有化，函数中的变量在外部调用不会污染全局变量 &#x2F;&#x2F;以后用于模块化开发 防止污染全局变量","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"ES笔记","slug":"ES笔记","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2019/09/25/ES笔记/","link":"","permalink":"http://yoursite.com/2019/09/25/ES%E7%AC%94%E8%AE%B0/","excerpt":"数据类型","text":"数据类型 动态语言 数据类型取决于取值JS中分为七种内置类型，七种内置类型分为两大类型，基本类型和对象基本类型有六种：null,undefined,boolean,number,string,symbolNaN也属于number，并且NaN并不等于自身 类型转换对象在转换基本数据类型，首先会调用valueOf然后调用toString。并且这两个方法你是可以重写的let a = {valueOf(){ return 0 }}当然你也可以重写Symbol.toPrimitive,该方法在转基本类型时调用优先级最高12345678910111213let a &#x3D; &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return &#39;1&#39;; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;&#125;1 + a &#x2F;&#x2F; &#x3D;&gt; 3&#39;1&#39; + a &#x2F;&#x2F; &#x3D;&gt; &#39;12&#39; ​ 数字运算var a = 1 / 0 ; // Infinity Number var num = 0 / 0; // NaN Not a Number 四则运算符只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且假发运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 逻辑运算符&amp;&amp; || ！ &amp;&amp;先看第一表达式转换成布尔值的结果，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只要看到第二个表达式，就可以返回该表达式的值了。 转换成 与 的抽象概念来进行值的运算 如果前面是真 那么后面不管是什么都输出后面，后面是真都为真，输出后面也为真，后面是假即为假，即输出后面的假的 undefined，null，NaN，“”，0，false ==&gt; false; 预编译 函数声明整体提升 变量 声明提升 预编译发生在函数执行的前一刻 创建AO对象 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined 将实参值和形参统一 在函数体里面找函数声明，值赋予函数体 作用域作用域链scope chain --&gt; 0:AO --&gt; 1:GO1234567891011121314151617181920212223a &#x3D; 100;function demo(e) &#123; function e() &#123; &#125; arguments[0] &#x3D; 2; document.write(e); &#x2F;&#x2F; 2 if (a) &#123; var b &#x3D; 123; function c() &#123; &#x2F;&#x2F; &#125; &#125; var c; a &#x3D; 10; var a; document.write(b); &#x2F;&#x2F;undefined f &#x3D; 123; document.write(c);&#x2F;&#x2F; undefined document.write(a);&#x2F;&#x2F;10&#125;var a;demo(1);document.write(a); &#x2F;&#x2F;100document.write(f); &#x2F;&#x2F;123 闭包 闭包就是指由权访问另一个函数作用域中的变量的函数。 创建闭包的常见的方式就是在一个函数内部创建另一个函数当内部函数被保存到外部时，将会生成闭包；闭包会导致原有作用链不释放，造成内存泄漏。 内存泄漏可以理解为有用的内存因为原有作用链不释放，导致越来越少，就像是内存泄漏了一样 123456789101112function a()&#123; var num &#x3D; 100; function b()&#123; num ++; console.log(num); &#125; return b;&#125; var demo &#x3D; a(); demo(); &#x2F;&#x2F;101 demo(); &#x2F;&#x2F;100 这里有对局部和全局变量有一个模糊的印象 闭包的作用 实现公有变量 eg:函数累加器 可以做缓存 eg:eater 可以实现封装，属性私有化。 eg: Person(); 模块化开发，防止污染全局变量 立即执行函数 立即执行函数，执行完就会被销毁/释放，只被执行一次 针对初始化功能的函数 123function ()&#123;&#125;() 能被执行符号执行的表达式就是立即执行函数/被忽视函数名 ！() 都可以将函数变成表达式 function(){ }();(function(){ }()) (function(){ })(); 123var test &#x3D; function()&#123; console.log(&#39;a&#39;);&#125;(); 对象对象的创建方法JS的对象创建不同于Java，c++，不需要类来定义属性和方法，直接在对象上定义属性和方法，更贴近面向对象，把对象当成一个真的的事物 var obj = {} 对象字面量/对象直接量 构造函数 系统自带的构造函数 Object() Array() Number() var obj = new Object(); 自定义构造函数//大驼峰式命名规则 function Person(){ } var person1 = new Person(); 就相当于创建了一个空对象 构造函数内部原理 在函数体的最前面隐式的加上this = {} 执行this.xxx = xxx; 隐式的返回this123456789function Person(name,age,sex)&#123; &#x2F;&#x2F;var this &#x3D; &#123;&#125; 一个空对象 this.name &#x3D; name; &#x2F;&#x2F; 往this里面加，name : &quot;xx&quot;, this.age &#x3D; age; this.sex &#x3D; sex; &#x2F;&#x2F;return this; &#125; var person1 &#x3D; new Person(&#39;zhangsan&#39;,18,&#39;man&#39;); 原型 定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 利用原型特点和概念，可以提取共有属性 对象如何查看原型 — &gt; 隐式属性 proto 对象如何查看对象的构造函数 — &gt; constructor 1234567891011Person.prototype --原型Person.prototype &#x3D; &#123;&#125; 是祖先Person.prototype.name &#x3D; &quot;hehe&quot;;function Person()&#123;&#125;var person &#x3D; new Person();&#x2F;&#x2F;新建的对象可以继承Person原型的属性和方法 call/apply 借用构造函数作用，改变this指向。区别，后面传的参数形式不同12345678910111213141516171819function Person(name, age, sex)&#123; this.name &#x3D; name; this.age &#x3D; age; this.sex &#x3D; sex; &#125; var person &#x3D; new Person(&#39;li&#39;, 18 , &#39;man&#39;); var obj &#x3D; &#123;&#125; Person.call(obj,&#39;tang&#39;,20,&#39;famale&#39;); &#x2F;&#x2F;call 借用别人的方法实现自己的功能 输出obj obj &#123;name: &quot;tang&quot;, age: 20, sex: &quot;famale&quot;&#125; person Person &#123;name: &quot;li&quot;, age: 18, sex: &quot;man&quot;&#125; 123456789101112function Person(name, age, sex) &#123; this.name &#x3D; name; this.age &#x3D; age; this.sex &#x3D; sex; &#125; function Student(name, age, sex, tel, grade) &#123; Person.call(this, name, age, sex); &#x2F;&#x2F;这样来调用Person的方法 this.tel &#x3D; tel; this.grade &#x3D; grade; &#125; var student &#x3D; new Student(&#39;tang&#39;, 18, &#39;female&#39;, 123, 99); call 需要把实参按照形参的个数传进去apply 需要传一个arguments的形式两者就是传参的形式不同1Person.apply(this,[name,age,se]); 继承 传统形式 过多的继承了没用的属性 借用构造函数 不能继承借用构造函数的原型 每次构造函数都要多走一个函数 共享原型 不能随便改动自己的原型 圣杯模式 123456789101112131415161718192021现在 - 圣杯模式 在共享原型基础上function inherit(Target, Origin)&#123; function F()&#123;&#125; F.prototype &#x3D; Origin.prototype; Target.prototype &#x3D; new F(); Target.prototype.constuctor &#x3D; Target; Target.prototype.uber &#x3D; Origin.prototype; &#x2F;&#x2F;继承谁 &#125; Father.prototype.lastName &#x3D; &#39;li&#39;; function Father()&#123; &#125; function Son()&#123; &#125; inherit(Son, Father); var son &#x3D; new Son(); var father &#x3D; new Father(); 此时Son这个构造函数能够继承原来Father的原型的属性，而且自己能够更改原型属性的同时，不会影响到father的原型属性。 命名空间定义一个命名空间 管理变量，防止污染全局，适用于模块化开发 查看属性，对象枚举for in 遍历对象 123456789101112131415var obj &#x3D; &#123; name : &#39;ljh&#39;, age : 123, sex : &#39;male&#39;, height : 180, weight : 75 &#125; for(var prop in obj)&#123; console.log(prop + &quot; &quot; + typeof(prop)); &#x2F;&#x2F; 下面结果为5个undefined，因为要想得到属性值，有了属性名后， &#x2F;&#x2F; obj.prop --&gt;obj[&#39;prop&#39;]这时的prop就是字符串属性名，obj没有prop属性 所以返回undefined &#x2F;&#x2F; conslole.log(obj.prop); console.log(obj[prop]); &#x2F;&#x2F;属性值 &#125; 1234567891011121314var obj &#x3D; &#123; name: &#39;ljh&#39;, age: 123, sex: &#39;male&#39;, height: 180, weight: 75, __proto__: &#39;deng&#39; &#x2F;&#x2F;加上原型的属性，下面依然会打印 &#125; for (var prop in obj) &#123; &#x2F;&#x2F;加上hasOwnProperty方法判断prop是否为本身属性 if (obj.hasOwnProperty(prop)) &#123; console.log(obj[prop]); &#125; &#125; in 也可以判断属性是否为对象的，但是会将父类的也算进去 注意使用时要用字符串，不然会被系统当成变量，属性名是字符串 ‘height’ in obj true‘lastName’ in obj true instanceof A instanceof B 看A对象的原型链上有没有 B的原型 A对象是不是B构造函数构造出来的 this 函数预编译过程 this —&gt; window 全局作用域里 this —&gt; window call/apply 可以改变函数运行时this指向 obj.func(); func()里面的this指向obj) 谁调用this指向谁 123456789101112131415161718192021&#x2F;&#x2F;this 面试题var name &#x3D; &#39;222&#39;;var a &#x3D; &#123; name : &#39;111&#39;, say : function()&#123; console.log(this.name); &#125;&#125; var fun &#x3D; a.say; &#x2F;&#x2F;222 把a对象中的函数拿出来在全局执行 所有是全局的namefun(); a.say(); &#x2F;&#x2F;&#x2F;111var b &#x3D; &#123; name : &quot;333&quot;, say : function (fun)&#123; &#x2F;&#x2F;this --&gt; b 这里面的this还是指向b，但是下面函数执行时直接执行，没有人调用，执行就是预编译环境，就是windows fun(); &#125;&#125;b.say(a.say); &#x2F;&#x2F;222 a.say当成一个参数就是一个函数 然后在b里面被执行b.say &#x3D; a.say;b.say(); &#x2F;&#x2F;333 arguments arguments.callee 等于函数自身的引用 123function test()&#123; console.log(argumens.callee);&#125; test(); 1234567var num &#x3D; (function (n)&#123; if(n &#x3D;&#x3D; 1)&#123; return 1; &#125; return n * arguments.callee(n - 1);&#125;(10)) caller 指函数被调用被执行时的环境时哪个环境 克隆 浅层克隆12345678910111213141516var obj &#x3D; &#123; name : &#39;tom&#39;, age : 18, sex : &#39;male&#39;&#125;var target &#x3D; &#123;&#125;function clone(origin, target)&#123; var target &#x3D; target || &#123;&#125;; for(var prop in origin)&#123; target[prop] &#x3D; oringin[prop]; &#125; return target;&#125;&#x2F;&#x2F;但是当对象有引用值(数组)时，改变target中的引用值，origin中的引用值也会改变 深度克隆12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;&#x2F;深度克隆&#x2F;&#x2F;遇到引用值时需要判断，何种引用值，新建一个引用，将原来的值填入&#x2F;&#x2F;遍历对象 for(var prop in obj)&#x2F;&#x2F;1.判断是否原始值(基本数据类型) 用typeof 判断是否object&#x2F;* 2.判断时数组还是对象 &#123; istanceof toString constructor&#125; *&#x2F;&#x2F;&#x2F;3.建立相应的数组或对象&#x2F;&#x2F;4.递归 var obj &#x3D; &#123; name: &#39;abc&#39;, age: 23, card: [&#39;visa&#39;, &#39;master&#39;], wife: &#123; name: &#39;bcd&#39;, son: &#123; name: &#39;aaa&#39; &#125; &#125; &#125; var obj1 &#x3D; &#123; &#125; function deepClone(Origin, target) &#123; var target &#x3D; target || &#123;&#125;, &#x2F;&#x2F;容错 如果有就有 没有就新建一个 toStr &#x3D; Object.prototype.toString, arrStr &#x3D; &quot;[object Array]&quot;; &#x2F;&#x2F;两者比对判断是否数组 for (var prop in origin) &#123; &#x2F;&#x2F;加上hasOwnProperty方法判断prop是否为本身属性 不拿原型链上的值 if (obj.hasOwnProperty(prop)) &#123; if (typeof (origin[prop]) &#x3D;&#x3D; &#39;object&#39; &amp;&amp; origin[prop]!&#x3D;&#x3D; &#39;null&#39;) &#123; &#x2F;&#x2F;判断引用值是否为数组 建立新数组或对象 if (toStr.call(origin[prop]) &#x3D;&#x3D; arrStr) &#123; target[prop] &#x3D; []; &#125; else &#123; target[prop] &#x3D; &#123;&#125;; &#125; deepClone(origin[prop], target[prop]); &#125; else &#123; target[prop] &#x3D; origin[prop]; &#125; &#125; &#125; return target; &#125; 封装 type方法1234567891011121314151617181920212223&#x2F;&#x2F;封装一个typeof函数 &#x2F;&#x2F;1. 分两类 原始值 引用值 &#x2F;&#x2F;2. 区分引用值 function type(target) &#123; var ret &#x3D; typeof(target); var template &#x3D; &#123; &quot;[object Array]&quot;: &#39;array&#39;, &quot;[object Object]&quot;: &#39;object&#39;, &quot;[object Number]&quot;: &#39;number - object&#39;, &quot;[object Boolean]&quot;: &#39;boolean - object&#39;, &quot;[object String]&quot;: &#39;string - object&#39;, &#125; if (target &#x3D;&#x3D; null) &#123; return &#39;null&#39;; &#125; else if (ret &#x3D;&#x3D; &#39;object&#39;) &#123; var str &#x3D; Object.prototype.toString.call(target); return template[str]; &#125; else &#123; return ret; &#125; &#125; 三目运算符 条件判断 ? 是 : 否 并且会返回值 var num = 1 &gt; 0 ? 2 + 2 : 1 + 1; //1大于0吗 是 返回2 + 2 不是 返回 1 + 1 var num = 1 &gt; 0 ? (“10” &gt; “9” ? 1 : 0) : 2;字符串比对 比对ascii码 10 小于 9 返回0 上面深度克隆里可以用三目运算符稍微简化一些if 数组数组在js中就是一种特殊的对象 两种方式定义数组 var arr = [];var arr = new Array(); 数组常用的几个方法， 改变原数组push,pop,shift,unshift,sort,reverse,splice arr.splice(从第几位开始，截取多少的长度，在切口处添加新的数据) 123var arr &#x3D; [1,2,3,5];arr.splice(3,0,4);&#x2F;&#x2F;arr&#x3D;[1,2,3,4,5p] 按照ascii码排序sort 给数组排序 升序arr.sort().reverse() 变降序了 系统提供重写sort方法 内部原理 冒泡排序 必须要有两个形参 看返回值 1. 当返回值为负数时，那么前面的数放在前面 2. 为整数，那么后面的数在前 3. 为0 不动123456789101112131415161718var arr &#x3D; [20,2,10,23,4,34,5,6]; arr.sort(function (a,b))&#123; &lt;!-- if(a &gt; b)&#123; return 1; &#125;else&#123; return -1; &#125; --&gt; return a - b; &#x2F;&#x2F;升序 &#125;;&#x2F;&#x2F;给一个有序的数组，乱序var arr &#x3D; [1,2,3,4,5,6];arr.sort(function()&#123; return Math.random() - 0.5;&#125;) 不改变原数组concat,join–&gt;split,toString,slice 123456789101112131415161718192021222324&#x2F;&#x2F;数组去重 &#x2F;&#x2F;要求在原型链上编程 &#x2F;* 该方法利用对象的特性来去重，对象中属性名不可能会相同， 将数组中每一位取出来，放到对象中当属性名，最开始相同的数组值放对象里 给它一个属性值，下面相同的数组值时就无法进入对象，再把对象的属性名push 到一个空的数组中，返回数组 *&#x2F; var arr &#x3D; [1,1,2,2,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;]; Array.prototype.unique &#x3D; function () &#123; var temp &#x3D; &#123;&#125;; var arr &#x3D; [], len &#x3D; this.length; for(i &#x3D; 0;i &lt; len; i ++)&#123; if(!temp[this[i]])&#123; &#x2F;&#x2F;原来没有值的时候就是undefined，!undefined就是true temp[this[i]] &#x3D; &#39;6&#39;; arr.push(this[i]); &#125; &#125; return arr; &#125; 类数组 可以利用属性名模拟数组的特性 可以动态的增长length属性 如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充12345678910111213141516171819202122function test()&#123; console.log(arguments); &#125; test(1,2,3,4,5); &#x2F;&#x2F;输出 [1,2,3,4,5] 但不是数组 类数组 &#x2F;&#x2F;类数组 对象 var obj &#x3D; &#123; &quot;0&quot; : &#39;a&#39;, &quot;1&quot; : &#39;b&#39;, &quot;2&quot; : &#39;c&#39;, &quot;length&quot; : 3, &quot;push&quot; : Array.prototype.push, &#125; &#x2F;&#x2F;属性要为索引(数字)属性，必须有length属性，最好加上push &#x2F;&#x2F;length决定在哪一位上push &#x2F;&#x2F; Array.prototype.push &#x3D; function (target)&#123; &#x2F;&#x2F; obj[obj.length] &#x3D; target; &#x2F;&#x2F; obj.length ++; &#x2F;&#x2F; &#125; try catch在try里面发生错误，不会执行错误后的try里的代码，try外的继续， try{}catch(e) {}finally{}Error.name的六种值对应的信息： EvalError：eval()的使用与定义不一致 RangeError：数值越界 ReferenceError：非法或不能识别的引用数值 SyntaxError：发生语法解析错误 TypeError：操作数类型错误 URIError：URI处理函数使用不当","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}