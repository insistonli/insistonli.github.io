{"meta":{"title":"李金朋Blog","subtitle":null,"description":null,"author":"李金朋","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"un11fin11","updated":"un33fin33","comments":false,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"un11fin11","updated":"un33fin33","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"记录 复习 学习 希望能坚持。。。。桃李不言 下自成蹊"},{"title":"书单","date":"un11fin11","updated":"un33fin33","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"un11fin11","updated":"un33fin33","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"un11fin11","updated":"un33fin33","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"un11fin11","updated":"un33fin33","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"un11fin11","updated":"un33fin33","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue","slug":"Vue","date":"un11fin11","updated":"un33fin33","comments":true,"path":"2020/03/23/Vue/","link":"","permalink":"http://yoursite.com/2020/03/23/Vue/","excerpt":"Vue 声明式编程vue指令/基本语法","text":"Vue 声明式编程vue指令/基本语法 v-bind 绑定属性简写 在属性前加 : 绑定多个class v-bind动态绑定 动态绑定class(对象语法，数组语法) 对象语法 :class = {class : ture/false} 是否存在在data里用变量控制 用数组[] :class=”[class1, class2]” value可以为ture或者flase 控制class1 是否添加 :class=”[{class1: value}, class2]”数据用参数的形式传入dom元素中去 绑定style 添加样式可以用对象的形式 :style={width: xxx,background: yy} 绑定多个style时用对象或数组 12345678910111213141516171819:style&#x3D;&quot;[&#123;width: imgWidth&#125;, imgStyle]&quot;:style &#x3D; &quot;getStyles()&quot;const vm &#x3D; new Vue(&#123; el : &#39;#app&#39; data: &#123; imgWidth: &#39;200px&#39;, imgStyle: &#123; border: &#39;10px solid red&#39; &#125; &#125;, methods: &#123; getStyles: function()&#123; return &#123;width: imgWidth,backgroundColor: red&#125; &#125; &#125;&#125;) ​ v-on指令 实现事件监听一、简写 @click = “handleClick” 点击事件123456789101112131415161718&lt;button @click = \"handleClick\"&gt;&lt;/button&gt;&lt;button @click = \"btnClick(abc,$event)\"&gt;&lt;/button&gt; const vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; handleClick()&#123; &#125;, btnClick('aa',event)&#123; &#125; &#125; &#125;) 当通过methods中定义方法，以供@click调用时， 如果该方法不需要额外参数，那么方法后的()可以不添加 如果方法中本身有一个参数，那么会默认将原生事件event参数传递进去 如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件 btnClick(abc,$event) 二、v-on修饰符 .stop修饰符可以做到阻止冒泡的作用 12345678&lt;div @click=\"divClick\"&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;//这里会有事件冒泡发生 点击按钮，div上也会有反应 &lt;div @click=\"divClick\"&gt; &lt;button @click.stop=\"btnClick\"&gt;按钮&lt;/button&gt;&lt;/div&gt; .prevent可以阻止默认事件 123&lt;form action&#x3D;&quot;baidu&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; @click.prevent &#x3D; &quot;submitClick&quot;&gt;&lt;&#x2F;form&gt; .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调 12&#x2F;&#x2F;监听按下回车抬起时动作&lt;input type&#x3D;&quot;text&quot; @keyup.enter &#x3D; &quot;keyup&quot;&gt; .native - 监听组件根元素的原生事件 .once - 只触发一次回调 v-if指令 实现显示和隐藏/ v-show1. v-if 和 v-else if等(操作DOM) 123456&#x2F;&#x2F;用于判断决定是否渲染，布尔值可以用变量控制&lt;template&gt; &lt;div v-if &#x3D; &quot;布尔值&quot;&gt;&#123;&#123; &#125;&#125;&lt;&#x2F;div&gt; &lt;div v-else if &#x3D; &quot;布尔值&quot;&gt;&#123;&#123; &#125;&#125;&lt;&#x2F;div&gt; &lt;div v-else&gt;&#123;&#123; &#125;&#125;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 123456789101112131415161718192021222324&lt;div id&#x3D;&quot;id&quot;&gt; &lt;span v-if &#x3D; &quot;isUser&quot;&gt; &lt;label for&#x3D;&quot;username&quot;&gt;用户账号&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; placeholder&#x3D;&quot;用户名登录&quot;&gt; &lt;&#x2F;span&gt; &lt;span v-else&gt; &lt;label for&#x3D;&quot;emaii&quot;&gt;用户邮箱&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;email&quot; placeholder&#x3D;&quot;用户邮箱&quot;&gt; &lt;&#x2F;span&gt; &lt;button @click &#x3D; &quot;isUser &#x3D; !isUser&quot;&gt;切换&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;.&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; isUser: true &#125; &#125;) &lt;&#x2F;script&gt; &#x2F;&#x2F;解决 &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; placeholder&#x3D;&quot;用户名登录&quot; key&#x3D;&quot;username&quot;&gt; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;email&quot; placeholder&#x3D;&quot;用户邮箱&quot; key&#x3D;&quot;email&quot;&gt; 小问题：** 如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前输入的内容 因为Vue在进行DOM渲染时，出于性能的考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。先会有一个虚拟DOM。 解决：可以给对应的input添加key，并且要保证key的不同 2. v-show(操作样式) 也是决定dom要不要显示出来，其实是改变元素的行内样式 当显示隐藏切片很频繁时，用v-show；一次切换用v-if v-for指令 循环遍历 遍历数组 遍历对象 v-for绑定key 1234567891011121314151617&lt;div id&#x3D;&quot;id&quot;&gt; &lt;ul&gt; &lt;li v-for &#x3D; &quot;item in letters&quot; :key &#x3D; &quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;.&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; letters: [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;] &#125;, methods: &#123; &#125; &#125;)&#x2F;&#x2F;插入F vm.letters.splice(2,0,&#39;F&#39;);&#x2F;&#x2F;splice可以删除，插入，替换元素 数组常用的方法 都能做到响应式，但是通过索引直接改变不行 12345678910111213141516171819202122232425262728&#x2F;&#x2F;小demo&lt;&#x2F;script&gt; --&gt; &lt;!-- 点击列表中的哪一项，那么该项的文字变成红色 --&gt; &lt;div id&#x3D;&quot;id&quot;&gt; &lt;template&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;(item,key) in movies&quot; :class&#x3D;&quot;&#123;red:currentIndex &#x3D;&#x3D;&#x3D; key&#125;&quot; @click&#x3D;&quot;change(key)&quot;&gt;&#123;&#123; item &#125;&#125;--&#123;&#123;key&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;template&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;.&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; movies: [&#39;花王&#39;, &#39;2&#39;, &#39;3&#39;], currentIndex: 0 &#125;, methods: &#123; change(key)&#123; this.currentIndex &#x3D; key; &#125; &#125; &#125;) &lt;&#x2F;script&gt; v-model 双向绑定 原理 v-bind绑定input value值，使value值可以由data控制，翻过来监听input事件，监听此时输入的数据，再将message值实时的等于数据，用event对象 123456789101112131415161718192021&lt;!-- v-model原理 --&gt; &lt;div id&#x3D;&quot;id&quot;&gt; &lt;!-- input事件用于监听用户输入 --&gt; &lt;!-- &lt;input type&#x3D;&quot;text&quot; :value &#x3D; &quot;message&quot; @input&#x3D;&quot;valueChange&quot;&gt; --&gt; &lt;input type&#x3D;&quot;text&quot; :value &#x3D; &quot;message&quot; @input&#x3D;&quot;message &#x3D; $event.target.value&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;..&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; message: &#39;你好啊&#39; &#125;, methods: &#123; valueChange(event)&#123; this.message &#x3D; event.target.value; &#125; &#125; &#125;) &lt;&#x2F;script&gt; 当界面改变时，数据也会发生改变 绑定input元素 123456789101112131415&lt;div id&#x3D;&quot;id&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model &#x3D; &quot;message&quot;&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;.&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; message: &#39;你好啊&#39; &#125;, methods: &#123; &#125; &#125;) &lt;&#x2F;script&gt; v-model: radio 当存在多个单选框时，可以用v-model绑定 v-model: checkbox 复选框分为两种情况：单个勾选框和多个勾选框 单选框通过false和ture可控制 多选框通过数组【】返回值 123456789101112131415161718192021222324252627282930&lt;!-- 1. checkbox单选框 --&gt; &lt;div id&#x3D;&quot;id&quot;&gt; &lt;label for&#x3D;&quot;agree&quot;&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;agree&quot; v-model&#x3D;&quot;isAgree&quot;&gt;同意协议 &lt;&#x2F;label&gt; &lt;h2&gt;您选择的是: &#123;&#123;isAgree&#125;&#125;&lt;&#x2F;h2&gt; &lt;button :disabled&#x3D;&quot;!isAgree&quot;&gt;下一步&lt;&#x2F;button&gt; &lt;!-- 2. checkbox多选框 --&gt; &lt;label for&#x3D;&quot;&quot;&gt; &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;篮球 &quot; v-model&#x3D;&quot;hobbies&quot;&gt;篮球 &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;足球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;足球 &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;排球 &quot; v-model&#x3D;&quot;hobbies&quot;&gt;排球 &lt;&#x2F;label&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;..&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; isAgree: false, hobbies: [] &#125;, methods: &#123; &#125; &#125;) &lt;&#x2F;script&gt; 多选框的值放入数组 可以传给其他 v-model:select（比较少见了） 分为单选和多选两种情况 单选 只能选中一个值 v-model绑定的是一个值 当我们选中option中的一个时，会将它对应的value赋值到mySlect中 多选：可以选中多个值 v-model绑定的是一个数组，当选中多个值时，就会将选中的option对应的value添加到数组mySelect中 12345678910111213141516171819202122232425262728293031323334&lt;div id&#x3D;&quot;id&quot;&gt; &lt;!-- 1. 选择一个 --&gt; &lt;select name&#x3D;&quot;abc&quot; id&#x3D;&quot;&quot; v-model&#x3D;&quot;fruit&quot;&gt; &lt;option value&#x3D;&quot;苹果&quot;&gt;苹果&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;香蕉&quot;&gt;香蕉&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;橘子&quot;&gt;橘子&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;葡萄&quot;&gt;葡萄&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;h2&gt;选择&#123;&#123; fruit &#125;&#125;&lt;&#x2F;h2&gt; &lt;!-- 2. 选择多个 --&gt; &lt;select name&#x3D;&quot;abc&quot; id&#x3D;&quot;&quot; v-model&#x3D;&quot;fruits&quot; multiple&gt; &lt;option value&#x3D;&quot;苹果&quot;&gt;苹果&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;香蕉&quot;&gt;香蕉&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;橘子&quot;&gt;橘子&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;葡萄&quot;&gt;葡萄&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;h2&gt;选择&#123;&#123; fruits &#125;&#125;&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;..&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; isAgree: false, hobbies: [], fruit: &#39;香蕉&#39;, fruits: [] &#125;, methods: &#123; &#125; &#125;) &lt;&#x2F;script&gt; 通过值绑定：利用v-bind动态绑定input中的value值，下面是input多选框动态绑定 12345678910111213&lt;!-- 通过值绑定 v-bind在input中的应用--&gt; &lt;label v-for&#x3D;&quot;item in originHobbies &quot; :for&#x3D;&quot;item&quot;&gt; &lt;input type&#x3D;&quot;checkbox&quot; :value&#x3D;&quot;item&quot; :id&#x3D;&quot;item&quot; v-model&#x3D;&quot;hobbies&quot;&gt;&#123;&#123; item &#125;&#125; &lt;&#x2F;label&gt; -------------------------------- data: &#123; isAgree: false, hobbies: [], fruit: &#39;香蕉&#39;, fruits: [], originHobbies: [&#39;篮球&#39; , &#39;足球&#39; , &#39;排球&#39;] &#125;, 修饰符 v-model.lazy=””…. 计算属性 计算属性的本质 fullname：{set(),get()} 某些情况，我们需要对数据进行一些转化后再显示，或者需要将多个数据结合起来显示，例如一起联合，我们可以将它换成计算属性，计算属性是卸载实例的computed选项中的 12345678910111213const app &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; firstName: &#39;lebron&#39;, lastName: &#39;james&#39; &#125;, &#x2F;&#x2F;computed: 计算属性() computed: &#123; fullName: function()&#123; return this.firstName + &#39; &#39; + this.lastName &#125; &#125;&#125;) 1234567891011121314151617181920212223242526272829const app &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; books: [ &#123;id: 110, name: &#39;数学&#39;, price: 119&#125;, &#123;id: 111, name: &#39;代码大全&#39;, price: 105&#125;, &#123;id: 112, name: &#39;深入理解计算机原理&#39;, price: 98&#125;, &#123;id: 113, name: &#39;语文&#39;, price: 89&#125; ] &#125;, &#x2F;&#x2F;computed: 计算属性() computed: &#123; &#x2F;&#x2F; filter&#x2F;map&#x2F;reduce totalPrice: funtion ()&#123; let result &#x3D; 0; for (let i &#x3D; 0; i &lt; this.books.length; i++)&#123; result +&#x3D; this.books[i].price &#125; return result; &lt;!--for (let i in this.books)&#123; this.books[i] &#125; for (let book of this.books)&#123; &#125;--&gt; &#125; &#125;&#125;) 每个计算属性都包括一个getter和一个setter methods和computed看起来都可以实现我们的功能，计算属性辉进行缓存，如果多次使用时，计算属性只会调用一次 12345678910111213141516171819202122232425262728293031&lt;!-- 多次执行的时候computed只会调用一次，计算属性有缓存 --&gt; &lt;div id&#x3D;&quot;id&quot;&gt; &lt;template&gt; &lt;!-- 通过methods --&gt; &lt;div&gt;&#123;&#123; getFullName() &#125;&#125;&lt;&#x2F;div&gt; &lt;div&gt;&#123;&#123; getFullName() &#125;&#125;&lt;&#x2F;div&gt; &lt;!-- 通过computed计算属性 --&gt; &lt;div&gt;&#123;&#123; fullName &#125;&#125;&lt;&#x2F;div&gt; &lt;div&gt;&#123;&#123; fullName &#125;&#125;&lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;.&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; firstName: &#39;li&#39;, lastName: &#39;tang&#39; &#125;, methods: &#123; getFullName: function()&#123; console.log(&#39;fullName&#39;); return this.firstName + &#39; &#39; + this.lastName; &#125; &#125;, computed: &#123; fullName: function()&#123; console.log(&#39;fullName&#39;) return this.firstName + &#39; &#39; + this.lastName; &#125; &#125; Vue的MVVM MVVM分为三个部分：分别是M（Model，模型层 ），V（View，视图层），VM（ViewModel，V与M连接的桥梁，也可以看作为控制器） M：模型层，主要负责业务数据相关；Data数据 V：视图层，顾名思义，负责视图相关，细分下来就是html+css层；就是DOM VM：V与M沟通的桥梁，负责监听M或者V的修改，是实现MVVM双向绑定的要点；在Vue中就是Vue MVVM支持双向绑定，意思就是当M层数据进行修改时，VM层会监测到变化，并且通知V层进行相应的修改，反之修改V层则会通知M层数据进行修改，以此也实现了视图与模型层的相互解耦； 关系图 vue的生命周期函数 组件组件的使用分成三个步骤： 创建组件构造器 调用Vue.extend()方法创建组件构造器 注册组件 调用Vue.component()方法注册组件 使用组件 在Vue实例的作用范围内使用组件 基本使用全局组件和局部组件注册组件(全局组件，意味着可以在多个Vue的实例下面使用) Vue.component(‘my-cpn’, cpnC) 注册的组件挂载在某个实例中，那么就是一个局部组件 ​ components: { ​ ‘my-cpn’: myComponent ​ } 为什么组件data时一个函数？ 为了能够实现数据的互不干扰，能够复用，如果直接使用对象，在实例中的数据更改会指向同一个对象 ，函数每次调用会产生不同的对象，有新的地址。 注册组件语法糖12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id&#x3D;&quot;id&quot;&gt; &lt;cpn2&gt;&lt;&#x2F;cpn2&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是标题1&lt;&#x2F;h2&gt; &lt;p&gt;我是内容&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; &#x2F;&#x2F;创建第一个组件构造器(子组件) const cpn1 &#x3D; &#123; template: &#39;#cpn&#39; &#125; &#x2F;&#x2F;创建第二个组件构造器(父组件) const cpnC2 &#x3D; &#123; template: &#96; &lt;div&gt; &lt;h2&gt;我是标题2&lt;&#x2F;h2&gt; &lt;p&gt;我是内容&lt;&#x2F;p&gt; &lt;cpn1&gt;&lt;&#x2F;cpn1&gt; &lt;&#x2F;div&gt;&#96;, components: &#123; cpn1 &#125; &#125; &#x2F;&#x2F;root根组件 const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; &#125;, methods: &#123; &#125;, components: &#123; cpn2: cpnC2 &#125; &#125;)&lt;&#x2F;script&gt; 组件数据的存放 组件对象也有一个data属性(也可以有methods等属性)，data属性必须时一个函数，而且这个函数返回一个对象，对象内部保存着数据，如上 父组件和子组件组件之间存在层级关系 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; &#x2F;&#x2F;创建第一个组件构造器(子组件) const cpnC1 &#x3D; Vue.extend(&#123; template: &#96; &lt;div&gt; &lt;h2&gt;我是标题1&lt;&#x2F;h2&gt; &lt;p&gt;我是内容&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &#96; &#125;) &#x2F;&#x2F;创建第二个组件构造器(父组件) const cpnC2 &#x3D; Vue.extend(&#123; template: &#96; &lt;div&gt; &lt;h2&gt;我是标题2&lt;&#x2F;h2&gt; &lt;p&gt;我是内容&lt;&#x2F;p&gt; &lt;cpn1&gt;&lt;&#x2F;cpn1&gt; &lt;&#x2F;div&gt; &#96;, components: &#123; cpn1: cpnC1 &#125; &#125;) const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; components: &#123; cpn2: cpnC2 &#125; &#125;, methods: &#123; &#125; &#125;) &lt;&#x2F;script&gt; vm实例也可以当作是一个组件，最顶层的组件root组件，在vue实例对应的实例div中，子标签不能直接使用，子组件在父组件中注册时，Vue会编译号父组件的模块，此时父组件的模板中已经全是将要渲染的HTML，包括子组件中的模板内容了。 父子组件通信 通过props向子组件传递数据 123456789101112131415161718&#x2F;&#x2F;1. 子组件 &#x2F;&#x2F;父传子： props const cpn &#x3D; &#123; template: &#39;#cpn1&#39;, &#x2F;&#x2F;数组形式 &#x2F;&#x2F; props: [&#39;cmovies&#39;], &#x2F;&#x2F;写成对象形式 props: &#123; &#x2F;&#x2F;1.类型限制 &#x2F;&#x2F; cmovies: Array, &#x2F;&#x2F;2.提供一些默认值 &#x2F;&#x2F;类型是对象或者数组时，默认值必须是一个函数 cmovies: &#123; type: String, &#x2F;&#x2F;默认类型 default: &#39;aaaaaaa&#39;, &#x2F;&#x2F;默认值 required: true &#x2F;&#x2F;表示必须传的值 &#125;, 通过事件向父组件发送消息 当子组件需要向符组件传递数据时就要用到自定义事件，用v-on监听组件间的自定义事件 在子组件中，通过$emit()来触发事件，在父组件中，通过v-on来监听子组件事件 一个父组件中，一个子组件可以传事件给父组件，父组件根据事件，可以做其他操作，例如显示另一个子组件的内容 其中props要求驼峰标识，在组件实例化的里面cIfo要写成c-info 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- props中的驼峰标识 --&gt; &lt;div id&#x3D;&quot;id&quot;&gt; &lt;!-- 这里用-i换I --&gt; &lt;cpn2 :c-info&#x3D;&quot;info&quot;&gt;&lt;&#x2F;cpn2&gt; &lt;&#x2F;div&gt; &lt;!-- 当模板中代码比较多时 要有一个根元素 --&gt; &lt;template id&#x3D;&quot;cpn2&quot;&gt; &lt;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script src&#x3D;&quot;..&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const cpn2 &#x3D; &#123; template: &#39;#cpn2&#39;, props: &#123; cInfo: &#123; type: Object, default()&#123; &#125; &#125; &#125; &#125; const vm &#x3D; new Vue(&#123; el: &#39;#id&#39;, data: &#123; info:&#123; name: &#39;why&#39;, age: 18 &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;&#x2F;script&gt; 父子组件的访问方式 父组件访问子组件 $children $refs 1234567891011methods: &#123; &#x2F;&#x2F; 1. 通过$children可以拿到子组件对象 存放在数组中 btnClick()&#123; &#x2F;&#x2F; console.log(this.$children); &#x2F;&#x2F; for(let c of this.$children)&#123; &#x2F;&#x2F; console.log(c.name); &#x2F;&#x2F; &#125; &#x2F;&#x2F;2. $refs console.log(this.$refs.aaa); &#x2F;&#x2F;可以取到aaa的子组件 &#125; 子组件访问父组件 较少 1234567btnClick() &#123; &#x2F;&#x2F;1. 访问父组件$parent console.log(this.$parent) &#x2F;&#x2F;2. 访问根组件$root console.log(this.$root); &#x2F;&#x2F;这里取到的时Vue实例 &#125; 插槽slot基本使用给组件添加插槽，用于改变组件中内容，具备扩展性。 例如同一个导航栏搜索栏 有相同部分和不同部分 不同部分使用slot便于扩展。 这时封装组件时要注意，最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽，使用者可以根据自己的需求，决定插槽中插入什么内容。 插槽的默认使用 插槽的默认值，直接在slot里写 按钮 如果有多个值，同时放入组件中进行替换时，一起作为替换元素 具名插槽可以指定某一个插槽的内容，给插槽一个name属性指定 作用域插槽的使用编译作用域：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译 作用域插槽准备 父组件替换插槽的标签，但是内容由子组件来提供,父组件想要将子组件的内容换一种方式展示 在父组件使用我们的子组件时，从子组件拿到数据 在使用子组件中我们通过获取到slot属性 再通过slot.data就可以获取到我们刚传入的data了 1234567891011121314151617181920212223242526272829303132&lt;div id&#x3D;&quot;id&quot;&gt; &lt;cpn&gt;&lt;&#x2F;cpn&gt; &lt;cpn&gt; &lt;!-- 目的是获取子组件的数据pLanguages 以-作为分割--&gt; &lt;template slot-scope&#x3D;&quot;slot&quot;&gt; &lt;!-- &lt;span v-for&#x3D;&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125; -&lt;&#x2F;span&gt; --&gt; &lt;span&gt;&#123;&#123;slot.data.join(&#39; - &#39;)&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;template&gt; &lt;&#x2F;cpn&gt; &lt;cpn&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt; &lt;template id&#x3D;&quot;cpn&quot;&gt; &lt;div&gt; &lt;slot :data&#x3D;&quot;pLanguages&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in pLanguages&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;components: &#123; cpn: &#123; template: &#39;#cpn&#39;, data() &#123; return &#123; pLanguages: [&#39;javascript&#39;, &#39;c&#39;, &#39;java&#39;, &#39;Python&#39;] &#125; &#125; &#125; &#125; 模块化开发为什么要模块化？ 因为模块化的代码只会运行在模块作用域，不会污染全局作用域，并且复用性高 模块化有两个核心：导出和导入 一、CommonJS的导出：12345678910&#x2F;&#x2F;这里是exports 不是exportmodule.exports &#x3D; &#123; flag: true, test(a,b)&#123; return a + b; &#125;, demo(a,b)&#123; return a * b; &#125;&#125; CommonJS的导入： 123456789&#x2F;&#x2F; CommonJS模块let &#123;test ,demo ,flag&#125; &#x3D; require(&#39;.&#x2F;aaa.js&#39;);let &#123;test ,demo ,flag&#125; &#x3D; require(&#39;moduleA&#39;);&#x2F;&#x2F;等同于let _mA &#x3D; require(&#39;moduleA&#39;);let test &#x3D; _mA.test;let demo &#x3D; _mA.demo;let flag &#x3D; _mA.flag; 二、ES的模块化实现export/importexport指令12345let name &#x3D; &#39;why&#39;let age &#x3D; 18let height &#x3D; 1.88export &#123;name, age, height&#125; import指令1import &#123;name, age&#125; from &quot;.&#x2F;xxx.js&quot; 某个情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名 这个时候可以使用export default; 注意export default在同一个模块中，不允许同时存在多个 vscode运行在node环境下，node用的是commonjs模块机制，import语法是es6提出来的模块机制，vscode用这个会报错 三、webpackwebpack可以让我们进行模块化开发，并且会帮助我们处理模块间的依赖关系，并且将其进行整合打包。前端模块化的打包工具。 grunt/gulp和webpack的不同： grunt/gulp更加强调的时前端流程的自动化，模块化不是它的核心。 webpack更加强调模块化开发管理，二文件压缩合并、预处理等功能，是他附带的功能。 准备工作 在packge.json中定义启动 安装本地局部的webpack：npm install webpack@3.6.0 –save-dev 局部安装 –save-dev 是开发时依赖，项目打包后不许继续使用的 安装完后本地会有一个node_modules文件夹 局部使用webpack： .\\node_modules.bin\\webpack 什么是loader？webpack会自动处理js之间相关的依赖，但是我们不仅仅由基本的js代码处理，我们也许哟啊加载css、图片，包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将/jsx、.vue转成js文件等。 这时要给webpack扩展对应的loader。 通过npm安装需要的loader 在webpack.config.js中的module关键字下进行配置 图片资源的加载也需要配置 使用url-loder和file-loader 其中配置图片的存储路径和存储名字 ES6转ES5 在webpack中如果需要ES6转ES5，使用babel对应的loader npm install –save-dev babel-loader@7 babel-core babel-preset-es2015 webpack使用vue配置npm install vue –save vue的使用el和template区别原来data中的数据显示在界面中，要修改需要到html文件湖中修改，然而后面的开发中不希望手动的来频繁修改html文件。 在vue实例中定义template属性 1234567891011new Vue(&#123; el: &#39;#app&#39;, template: &#96; &lt;div&gt; &#123;&#123;message&#125;&#125; &lt;&#x2F;div&gt; &#96;, data: &#123; message: &#39;xiaolizi&#39; &#125;&#125;) 同时有el和template template会将el的东西替换掉 .vue文件封装处理安装vue-loader和vue-template-compiler npm install vue-loader vue-template-compiler –save-dev 认识pluginloader主要用于转换某些类型的模块，是一个转换器 piugin是插件，它是对webpack本身的扩展，是一个扩展器 通过npm安装需要使用的plugins 在webpack.config.js中的plugins中配置插件 打包html的plugin 在真实发布项目时，发布的是dist文件夹的内容，但是dist文件夹中没用index.html文件的， HtmlWebpackPligin插件可以：自动生成一个index.html文件（可以制定模板生成） 将打包的js文件，自动通过script标签插入到body中 压缩Js的plugin 项目发布前要对打包的js文件进行压缩 这里使用第三方插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致 1npm install uglifyjs-webpack-plugin@1.1.1 --save-dev 修改webpack.config.js文件 搭建本地服务器webpack提供了一个可选的本地开发服务器，这个服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果 1npm install --save-dev webpack-dev-server@2.9.1 在webpack.config.js中，设置devserver选项，它具有如下属性： contentBase:为哪一个文件夹提供本地服务，默认啊hi根文件夹，我们这里要填写发布的文件夹./dist port:端口号 inline：页面实时刷新 historyApiFallback:在SPA页面中，依赖HTML5的history模式 配置文件的分离将生产环境配置与开发环境配置实现分离 需要安装webpack-merge Vue CLI使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置 12安装：npm install -g @vue&#x2F;cli安装2.0模板：npm install -g @vue&#x2F;cli-init Vue CLI2初始化项目 vue init webpack my-project Vue CLI3初始化项目 vue create my-project Vue CLI2初始化项目过程runtime+compiler和runtime+onlyvue运行 compiler: template -&gt; ast -&gt; render -&gt; vdom -&gt; UI(真实dom) only: render -&gt; vdom -&gt; UI 性能更优，代码更少 这里的render函数 是由vue-template-compiler 把template解析成对象后 Vue CLI3构建项目1npm create 项目名称 CLI3的配置去哪了？ 使用 vue ui能有一个可视化界面，在里面可以更改配置； 或者在项目文件夹里新建vue.config.js文件 将需要的配置导入 Vue-router前端渲染和后端渲染 前端渲染 后端渲染 安装和使用vue-router配置vue-router 在router/index.js中配置 导入路由对象，并且调用Vue.use(VueRouter) 创建路由实例，并且传入路由映射配置 在Vue实例中挂载创建的路由实例 1234import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;Vue.use(VueRouter) 路由的默认路径 默认情况下，我们希望router-view直接渲染首页的内容 但是我们的实现中默认没有显示首页组件，必须要用户点击 所以我们要多配置一个映射关系 123456const routes &#x3D; [ &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;home&#39; &#125;] 改成html5的history模式，在配置路由的映射中添加 mode：’history’ 路由的呈现router-link、router-view和用代码跳转路由123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;!-- 使用路由 --&gt; &lt;!-- &lt;router-link to&#x3D;&quot;&#x2F;home&quot; tag&#x3D;&quot;button&quot; replace&gt;首页&lt;&#x2F;router-link&gt; &lt;router-link to&#x3D;&quot;&#x2F;about&quot; tag&#x3D;&quot;button&quot; replace&gt;关于&lt;&#x2F;router-link&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; --&gt; &lt;button @click&#x3D;&quot;homeClick&quot;&gt;首页&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;aboutClick&quot;&gt;关于&lt;&#x2F;button&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;App&#39;, methods: &#123; homeClick()&#123; &#x2F;&#x2F; this.$router.push(&#39;.&#x2F;home&#39;) this.$router.replace(&#39;.&#x2F;home&#39;) &#125;, aboutClick()&#123; &#x2F;&#x2F; this.$router.push(&#39;.&#x2F;about&#39;) this.$router.repalce(&#39;.&#x2F;about&#39;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 动态路由的使用","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"vue笔记","slug":"vue笔记","permalink":"http://yoursite.com/tags/vue%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/03/23/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"e的移动尺寸变化和div移动的尺寸变化","slug":"事件源e和div的尺寸变化","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2020/03/18/事件源e和div的尺寸变化/","link":"","permalink":"http://yoursite.com/2020/03/18/%E4%BA%8B%E4%BB%B6%E6%BA%90e%E5%92%8Cdiv%E7%9A%84%E5%B0%BA%E5%AF%B8%E5%8F%98%E5%8C%96/","excerpt":"遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下","text":"遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下 对于点击事件源e来说 clientX，clientY点击位置距离当前可视区域的x，y坐标 pageX,pageY对于整个页面来说，包括了被卷去的body部分的长度 screenX，screenY点击位置距离当前电脑屏幕边界的x，y坐标 offsetX，offsetY相对于带有定位的父盒子的x，y坐标 对于div来说 ))","categories":[],"tags":[{"name":"关于e.clientX 和 div的clientX等其他属性的变化!","slug":"关于e-clientX-和-div的clientX等其他属性的变化","permalink":"http://yoursite.com/tags/%E5%85%B3%E4%BA%8Ee-clientX-%E5%92%8C-div%E7%9A%84clientX%E7%AD%89%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96/"}]},{"title":"实现不设置宽高的盒子的居中","slug":"实现不设置宽高的盒子的居中","date":"un11fin11","updated":"un33fin33","comments":true,"path":"2020/03/16/实现不设置宽高的盒子的居中/","link":"","permalink":"http://yoursite.com/2020/03/16/%E5%AE%9E%E7%8E%B0%E4%B8%8D%E8%AE%BE%E7%BD%AE%E5%AE%BD%E9%AB%98%E7%9A%84%E7%9B%92%E5%AD%90%E7%9A%84%E5%B1%85%E4%B8%AD/","excerpt":"有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现?","text":"有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现? 用css的transform中的translate可以实现,translate控制移动自身宽度的50%刚好实现垂直水平居中 123456789101112131415161718192021222324252627282930313233&lt;!-- 有两个div div2在div1中要实现垂直水平居中 --&gt;&lt;style&gt; *&#123; margin: 0; padding: 0%; &#125; .div1 &#123; position: relative; width: 500px; height: 500px; background-color: green; &#125; .div2 &#123; position: absolute; max-width: 300px; max-height: 300px; background-color: blue; left: 50%; top: 50%; transform: translate(-50%,-50%) &#125;&lt;&#x2F;style&gt;&lt;body&gt; &lt;div class&#x3D;&quot;div1&quot;&gt; &lt;div class&#x3D;&quot;div2&quot;&gt; daskjfhljsadhfkj &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"判断事件点击拖拽时距离","slug":"判断事件点击拖拽时距离","permalink":"http://yoursite.com/tags/%E5%88%A4%E6%96%AD%E4%BA%8B%E4%BB%B6%E7%82%B9%E5%87%BB%E6%8B%96%E6%8B%BD%E6%97%B6%E8%B7%9D%E7%A6%BB/"}]},{"title":"闭包","slug":"闭包","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/09/25/闭包/","link":"","permalink":"http://yoursite.com/2019/09/25/%E9%97%AD%E5%8C%85/","excerpt":"闭包","text":"闭包 闭包就是指由权访问另一个函数作用域中的变量的函数。 创建闭包的常见的方式就是在一个函数内部创建另一个函数 当内部函数被保存到外部时，将会生成闭包；闭包会导致原有 作用链不释放，造成内存泄漏。 内存泄漏可以理解为有用的内存因为原有作用链不释放，导致越来越少，就像是内存泄漏了一样 ​ 12345678910111213141516171819202122function a()&#123; var num &#x3D; 100; function b()&#123; num ++; console.log(num); &#125; return b;&#125; var demo &#x3D; a(); demo(); &#x2F;&#x2F;101 demo(); &#x2F;&#x2F;100 123456789101112131415161718192021222324function a() &#123; function b() &#123; var bbb &#x3D; 234; document.write(aaa); &#125; var aaa &#x3D; 123; return b; &#125; var glob &#x3D; 100; var demo &#x3D; a(); demo(); 1这里有对局部和全局变量有一个模糊的印象 闭包的作用 实现公有变量 eg:函数累加器 可以做缓存 eg:eater 可以实现封装，属性私有化。 eg: Person(); 模块化开发，防止污染全局变量 12345678910111213141516171819202122232425262728293031323334var name &#x3D; &#39;bcd&#39;; var init &#x3D; (function ()&#123; var name &#x3D; &#39;abc&#39;; function callName()&#123; console.log(name); &#125; return function()&#123; callName(); &#125; &#125;()) init(); &#x2F;&#x2F;运行后的结果为 abc &#x2F;&#x2F;这就是用闭包实现变量的私有化，函数中的变量在外部调用不会污染全局变量 &#x2F;&#x2F;以后用于模块化开发 防止污染全局变量","categories":[],"tags":[{"name":"闭包的最初笔记","slug":"闭包的最初笔记","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85%E7%9A%84%E6%9C%80%E5%88%9D%E7%AC%94%E8%AE%B0/"}]},{"title":"ES笔记","slug":"ES笔记","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/09/25/ES笔记/","link":"","permalink":"http://yoursite.com/2019/09/25/ES%E7%AC%94%E8%AE%B0/","excerpt":"数据类型","text":"数据类型 动态语言 数据类型取决于取值JS中分为七种内置类型，七种内置类型分为两大类型，基本类型和对象基本类型有六种：null,undefined,boolean,number,string,symbolNaN也属于number，并且NaN并不等于自身 类型转换对象在转换基本数据类型，首先会调用valueOf然后调用toString。并且这两个方法你是可以重写的let a = {valueOf(){ return 0 }}当然你也可以重写Symbol.toPrimitive,该方法在转基本类型时调用优先级最高12345678910111213let a &#x3D; &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return &#39;1&#39;; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;&#125;1 + a &#x2F;&#x2F; &#x3D;&gt; 3&#39;1&#39; + a &#x2F;&#x2F; &#x3D;&gt; &#39;12&#39; ​ 数字运算var a = 1 / 0 ; // Infinity Number var num = 0 / 0; // NaN Not a Number 四则运算符只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且假发运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 逻辑运算符&amp;&amp; || ！ &amp;&amp;先看第一表达式转换成布尔值的结果，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只要看到第二个表达式，就可以返回该表达式的值了。 转换成 与 的抽象概念来进行值的运算 如果前面是真 那么后面不管是什么都输出后面，后面是真都为真，输出后面也为真，后面是假即为假，即输出后面的假的 undefined，null，NaN，“”，0，false ==&gt; false; 预编译 函数声明整体提升 变量 声明提升 预编译发生在函数执行的前一刻 创建AO对象 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined 将实参值和形参统一 在函数体里面找函数声明，值赋予函数体 作用域作用域链scope chain --&gt; 0:AO --&gt; 1:GO1234567891011121314151617181920212223a &#x3D; 100;function demo(e) &#123; function e() &#123; &#125; arguments[0] &#x3D; 2; document.write(e); &#x2F;&#x2F; 2 if (a) &#123; var b &#x3D; 123; function c() &#123; &#x2F;&#x2F; &#125; &#125; var c; a &#x3D; 10; var a; document.write(b); &#x2F;&#x2F;undefined f &#x3D; 123; document.write(c);&#x2F;&#x2F; undefined document.write(a);&#x2F;&#x2F;10&#125;var a;demo(1);document.write(a); &#x2F;&#x2F;100document.write(f); &#x2F;&#x2F;123 闭包 闭包就是指由权访问另一个函数作用域中的变量的函数。 创建闭包的常见的方式就是在一个函数内部创建另一个函数当内部函数被保存到外部时，将会生成闭包；闭包会导致原有作用链不释放，造成内存泄漏。 内存泄漏可以理解为有用的内存因为原有作用链不释放，导致越来越少，就像是内存泄漏了一样 123456789101112function a()&#123; var num &#x3D; 100; function b()&#123; num ++; console.log(num); &#125; return b;&#125; var demo &#x3D; a(); demo(); &#x2F;&#x2F;101 demo(); &#x2F;&#x2F;100 这里有对局部和全局变量有一个模糊的印象 闭包的作用 实现公有变量 eg:函数累加器 可以做缓存 eg:eater 可以实现封装，属性私有化。 eg: Person(); 模块化开发，防止污染全局变量 立即执行函数 立即执行函数，执行完就会被销毁/释放，只被执行一次 针对初始化功能的函数 123function ()&#123;&#125;() 能被执行符号执行的表达式就是立即执行函数/被忽视函数名 ！() 都可以将函数变成表达式 function(){ }();(function(){ }()) (function(){ })(); 123var test &#x3D; function()&#123; console.log(&#39;a&#39;);&#125;(); 对象对象的创建方法JS的对象创建不同于Java，c++，不需要类来定义属性和方法，直接在对象上定义属性和方法，更贴近面向对象，把对象当成一个真的的事物 var obj = {} 对象字面量/对象直接量 构造函数 系统自带的构造函数 Object() Array() Number() var obj = new Object(); 自定义构造函数//大驼峰式命名规则 function Person(){ } var person1 = new Person(); 就相当于创建了一个空对象 构造函数内部原理 在函数体的最前面隐式的加上this = {} 执行this.xxx = xxx; 隐式的返回this123456789function Person(name,age,sex)&#123; &#x2F;&#x2F;var this &#x3D; &#123;&#125; 一个空对象 this.name &#x3D; name; &#x2F;&#x2F; 往this里面加，name : &quot;xx&quot;, this.age &#x3D; age; this.sex &#x3D; sex; &#x2F;&#x2F;return this; &#125; var person1 &#x3D; new Person(&#39;zhangsan&#39;,18,&#39;man&#39;); 原型 定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 利用原型特点和概念，可以提取共有属性 对象如何查看原型 — &gt; 隐式属性 proto 对象如何查看对象的构造函数 — &gt; constructor 1234567891011Person.prototype --原型Person.prototype &#x3D; &#123;&#125; 是祖先Person.prototype.name &#x3D; &quot;hehe&quot;;function Person()&#123;&#125;var person &#x3D; new Person();&#x2F;&#x2F;新建的对象可以继承Person原型的属性和方法 call/apply 借用构造函数作用，改变this指向。区别，后面传的参数形式不同12345678910111213141516171819function Person(name, age, sex)&#123; this.name &#x3D; name; this.age &#x3D; age; this.sex &#x3D; sex; &#125; var person &#x3D; new Person(&#39;li&#39;, 18 , &#39;man&#39;); var obj &#x3D; &#123;&#125; Person.call(obj,&#39;tang&#39;,20,&#39;famale&#39;); &#x2F;&#x2F;call 借用别人的方法实现自己的功能 输出obj obj &#123;name: &quot;tang&quot;, age: 20, sex: &quot;famale&quot;&#125; person Person &#123;name: &quot;li&quot;, age: 18, sex: &quot;man&quot;&#125; 123456789101112function Person(name, age, sex) &#123; this.name &#x3D; name; this.age &#x3D; age; this.sex &#x3D; sex; &#125; function Student(name, age, sex, tel, grade) &#123; Person.call(this, name, age, sex); &#x2F;&#x2F;这样来调用Person的方法 this.tel &#x3D; tel; this.grade &#x3D; grade; &#125; var student &#x3D; new Student(&#39;tang&#39;, 18, &#39;female&#39;, 123, 99); call 需要把实参按照形参的个数传进去apply 需要传一个arguments的形式两者就是传参的形式不同1Person.apply(this,[name,age,se]); 继承 传统形式 过多的继承了没用的属性 借用构造函数 不能继承借用构造函数的原型 每次构造函数都要多走一个函数 共享原型 不能随便改动自己的原型 圣杯模式 123456789101112131415161718192021现在 - 圣杯模式 在共享原型基础上function inherit(Target, Origin)&#123; function F()&#123;&#125; F.prototype &#x3D; Origin.prototype; Target.prototype &#x3D; new F(); Target.prototype.constuctor &#x3D; Target; Target.prototype.uber &#x3D; Origin.prototype; &#x2F;&#x2F;继承谁 &#125; Father.prototype.lastName &#x3D; &#39;li&#39;; function Father()&#123; &#125; function Son()&#123; &#125; inherit(Son, Father); var son &#x3D; new Son(); var father &#x3D; new Father(); 此时Son这个构造函数能够继承原来Father的原型的属性，而且自己能够更改原型属性的同时，不会影响到father的原型属性。 命名空间定义一个命名空间 管理变量，防止污染全局，适用于模块化开发 查看属性，对象枚举for in 遍历对象 123456789101112131415var obj &#x3D; &#123; name : &#39;ljh&#39;, age : 123, sex : &#39;male&#39;, height : 180, weight : 75 &#125; for(var prop in obj)&#123; console.log(prop + &quot; &quot; + typeof(prop)); &#x2F;&#x2F; 下面结果为5个undefined，因为要想得到属性值，有了属性名后， &#x2F;&#x2F; obj.prop --&gt;obj[&#39;prop&#39;]这时的prop就是字符串属性名，obj没有prop属性 所以返回undefined &#x2F;&#x2F; conslole.log(obj.prop); console.log(obj[prop]); &#x2F;&#x2F;属性值 &#125; 1234567891011121314var obj &#x3D; &#123; name: &#39;ljh&#39;, age: 123, sex: &#39;male&#39;, height: 180, weight: 75, __proto__: &#39;deng&#39; &#x2F;&#x2F;加上原型的属性，下面依然会打印 &#125; for (var prop in obj) &#123; &#x2F;&#x2F;加上hasOwnProperty方法判断prop是否为本身属性 if (obj.hasOwnProperty(prop)) &#123; console.log(obj[prop]); &#125; &#125; in 也可以判断属性是否为对象的，但是会将父类的也算进去 注意使用时要用字符串，不然会被系统当成变量，属性名是字符串 ‘height’ in obj true‘lastName’ in obj true instanceof A instanceof B 看A对象的原型链上有没有 B的原型 A对象是不是B构造函数构造出来的 this 函数预编译过程 this —&gt; window 全局作用域里 this —&gt; window call/apply 可以改变函数运行时this指向 obj.func(); func()里面的this指向obj) 谁调用this指向谁 123456789101112131415161718192021&#x2F;&#x2F;this 面试题var name &#x3D; &#39;222&#39;;var a &#x3D; &#123; name : &#39;111&#39;, say : function()&#123; console.log(this.name); &#125;&#125; var fun &#x3D; a.say; &#x2F;&#x2F;222 把a对象中的函数拿出来在全局执行 所有是全局的namefun(); a.say(); &#x2F;&#x2F;&#x2F;111var b &#x3D; &#123; name : &quot;333&quot;, say : function (fun)&#123; &#x2F;&#x2F;this --&gt; b 这里面的this还是指向b，但是下面函数执行时直接执行，没有人调用，执行就是预编译环境，就是windows fun(); &#125;&#125;b.say(a.say); &#x2F;&#x2F;222 a.say当成一个参数就是一个函数 然后在b里面被执行b.say &#x3D; a.say;b.say(); &#x2F;&#x2F;333 arguments arguments.callee 等于函数自身的引用 123function test()&#123; console.log(argumens.callee);&#125; test(); 1234567var num &#x3D; (function (n)&#123; if(n &#x3D;&#x3D; 1)&#123; return 1; &#125; return n * arguments.callee(n - 1);&#125;(10)) caller 指函数被调用被执行时的环境时哪个环境 克隆 浅层克隆12345678910111213141516var obj &#x3D; &#123; name : &#39;tom&#39;, age : 18, sex : &#39;male&#39;&#125;var target &#x3D; &#123;&#125;function clone(origin, target)&#123; var target &#x3D; target || &#123;&#125;; for(var prop in origin)&#123; target[prop] &#x3D; oringin[prop]; &#125; return target;&#125;&#x2F;&#x2F;但是当对象有引用值(数组)时，改变target中的引用值，origin中的引用值也会改变 深度克隆12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;&#x2F;深度克隆&#x2F;&#x2F;遇到引用值时需要判断，何种引用值，新建一个引用，将原来的值填入&#x2F;&#x2F;遍历对象 for(var prop in obj)&#x2F;&#x2F;1.判断是否原始值(基本数据类型) 用typeof 判断是否object&#x2F;* 2.判断时数组还是对象 &#123; istanceof toString constructor&#125; *&#x2F;&#x2F;&#x2F;3.建立相应的数组或对象&#x2F;&#x2F;4.递归 var obj &#x3D; &#123; name: &#39;abc&#39;, age: 23, card: [&#39;visa&#39;, &#39;master&#39;], wife: &#123; name: &#39;bcd&#39;, son: &#123; name: &#39;aaa&#39; &#125; &#125; &#125; var obj1 &#x3D; &#123; &#125; function deepClone(Origin, target) &#123; var target &#x3D; target || &#123;&#125;, &#x2F;&#x2F;容错 如果有就有 没有就新建一个 toStr &#x3D; Object.prototype.toString, arrStr &#x3D; &quot;[object Array]&quot;; &#x2F;&#x2F;两者比对判断是否数组 for (var prop in origin) &#123; &#x2F;&#x2F;加上hasOwnProperty方法判断prop是否为本身属性 不拿原型链上的值 if (obj.hasOwnProperty(prop)) &#123; if (typeof (origin[prop]) &#x3D;&#x3D; &#39;object&#39; &amp;&amp; origin[prop]!&#x3D;&#x3D; &#39;null&#39;) &#123; &#x2F;&#x2F;判断引用值是否为数组 建立新数组或对象 if (toStr.call(origin[prop]) &#x3D;&#x3D; arrStr) &#123; target[prop] &#x3D; []; &#125; else &#123; target[prop] &#x3D; &#123;&#125;; &#125; deepClone(origin[prop], target[prop]); &#125; else &#123; target[prop] &#x3D; origin[prop]; &#125; &#125; &#125; return target; &#125; 封装 type方法1234567891011121314151617181920212223&#x2F;&#x2F;封装一个typeof函数 &#x2F;&#x2F;1. 分两类 原始值 引用值 &#x2F;&#x2F;2. 区分引用值 function type(target) &#123; var ret &#x3D; typeof(target); var template &#x3D; &#123; &quot;[object Array]&quot;: &#39;array&#39;, &quot;[object Object]&quot;: &#39;object&#39;, &quot;[object Number]&quot;: &#39;number - object&#39;, &quot;[object Boolean]&quot;: &#39;boolean - object&#39;, &quot;[object String]&quot;: &#39;string - object&#39;, &#125; if (target &#x3D;&#x3D; null) &#123; return &#39;null&#39;; &#125; else if (ret &#x3D;&#x3D; &#39;object&#39;) &#123; var str &#x3D; Object.prototype.toString.call(target); return template[str]; &#125; else &#123; return ret; &#125; &#125; 三目运算符 条件判断 ? 是 : 否 并且会返回值 var num = 1 &gt; 0 ? 2 + 2 : 1 + 1; //1大于0吗 是 返回2 + 2 不是 返回 1 + 1 var num = 1 &gt; 0 ? (“10” &gt; “9” ? 1 : 0) : 2;字符串比对 比对ascii码 10 小于 9 返回0 上面深度克隆里可以用三目运算符稍微简化一些if 数组数组在js中就是一种特殊的对象 两种方式定义数组 var arr = [];var arr = new Array(); 数组常用的几个方法， 改变原数组push,pop,shift,unshift,sort,reverse,splice arr.splice(从第几位开始，截取多少的长度，在切口处添加新的数据) 123var arr &#x3D; [1,2,3,5];arr.splice(3,0,4);&#x2F;&#x2F;arr&#x3D;[1,2,3,4,5p] 按照ascii码排序sort 给数组排序 升序arr.sort().reverse() 变降序了 系统提供重写sort方法 内部原理 冒泡排序 必须要有两个形参 看返回值 1. 当返回值为负数时，那么前面的数放在前面 2. 为整数，那么后面的数在前 3. 为0 不动123456789101112131415161718var arr &#x3D; [20,2,10,23,4,34,5,6]; arr.sort(function (a,b))&#123; &lt;!-- if(a &gt; b)&#123; return 1; &#125;else&#123; return -1; &#125; --&gt; return a - b; &#x2F;&#x2F;升序 &#125;;&#x2F;&#x2F;给一个有序的数组，乱序var arr &#x3D; [1,2,3,4,5,6];arr.sort(function()&#123; return Math.random() - 0.5;&#125;) 不改变原数组concat,join–&gt;split,toString,slice 123456789101112131415161718192021222324&#x2F;&#x2F;数组去重 &#x2F;&#x2F;要求在原型链上编程 &#x2F;* 该方法利用对象的特性来去重，对象中属性名不可能会相同， 将数组中每一位取出来，放到对象中当属性名，最开始相同的数组值放对象里 给它一个属性值，下面相同的数组值时就无法进入对象，再把对象的属性名push 到一个空的数组中，返回数组 *&#x2F; var arr &#x3D; [1,1,2,2,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;]; Array.prototype.unique &#x3D; function () &#123; var temp &#x3D; &#123;&#125;; var arr &#x3D; [], len &#x3D; this.length; for(i &#x3D; 0;i &lt; len; i ++)&#123; if(!temp[this[i]])&#123; &#x2F;&#x2F;原来没有值的时候就是undefined，!undefined就是true temp[this[i]] &#x3D; &#39;6&#39;; arr.push(this[i]); &#125; &#125; return arr; &#125; 类数组 可以利用属性名模拟数组的特性 可以动态的增长length属性 如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充12345678910111213141516171819202122function test()&#123; console.log(arguments); &#125; test(1,2,3,4,5); &#x2F;&#x2F;输出 [1,2,3,4,5] 但不是数组 类数组 &#x2F;&#x2F;类数组 对象 var obj &#x3D; &#123; &quot;0&quot; : &#39;a&#39;, &quot;1&quot; : &#39;b&#39;, &quot;2&quot; : &#39;c&#39;, &quot;length&quot; : 3, &quot;push&quot; : Array.prototype.push, &#125; &#x2F;&#x2F;属性要为索引(数字)属性，必须有length属性，最好加上push &#x2F;&#x2F;length决定在哪一位上push &#x2F;&#x2F; Array.prototype.push &#x3D; function (target)&#123; &#x2F;&#x2F; obj[obj.length] &#x3D; target; &#x2F;&#x2F; obj.length ++; &#x2F;&#x2F; &#125; try catch在try里面发生错误，不会执行错误后的try里的代码，try外的继续， try{}catch(e) {}finally{}Error.name的六种值对应的信息： EvalError：eval()的使用与定义不一致 RangeError：数值越界 ReferenceError：非法或不能识别的引用数值 SyntaxError：发生语法解析错误 TypeError：操作数类型错误 URIError：URI处理函数使用不当","categories":[],"tags":[{"name":"之前学习的时候写的，现在传上来","slug":"之前学习的时候写的，现在传上来","permalink":"http://yoursite.com/tags/%E4%B9%8B%E5%89%8D%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%97%B6%E5%80%99%E5%86%99%E7%9A%84%EF%BC%8C%E7%8E%B0%E5%9C%A8%E4%BC%A0%E4%B8%8A%E6%9D%A5/"}]}]}