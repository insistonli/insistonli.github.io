<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李金朋Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-18T13:56:23.417Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李金朋</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事件循环</title>
    <link href="http://yoursite.com/2020/05/18/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2020/05/18/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-05-18T08:19:37.000Z</published>
    <updated>2020-05-18T13:56:23.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件循环-ignore"><a href="#事件循环-ignore" class="headerlink" title="事件循环 {ignore}"></a>事件循环 {ignore}</h1><p>[toc]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><strong>浏览器、JS、执行引擎的关系</strong></li></ol><p>JS：一门计算机语言，提供了表达程序逻辑的语法和实现基本功能的API</p><p>浏览器：JS语言的真实运行环境，又称之为JS的宿主环境</p><p>JS执行引擎：JS宿主环境（例如浏览器）中的一个功能模块，用于解析并执行JS</p><p>它们的关系如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBaf951fd4135c5c61f416c1c5b2be4fd9?method=download&shareKey=6b3fc46c45c93796213be24e4c7678ff" alt="image"></p><ol start="2"><li><strong>进程 和 线程</strong></li></ol><p>进程：当一个应用程序运行时，需要使用内存和CPU资源，这些资源需要向操作系统申请。操作系统以进程的方式来分配这些资源，一个进程就代表着一块独立于其他进程的内存空间。一个应用程序要运行，必须至少有一个进程启动。进程的最大特点是<strong>独立</strong>，一个进程不能随意的访问其他进程的资源。这就保证了多个程序在操作系统上运行互不干扰。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7810fd56bd67ac85d7af96d126992aa8?method=download&shareKey=1fbd3400480045115154215448af31f8" alt="image"></p><p>线程：可能要同时执行多个任务，每个任务需要在一个线程上运行，线程与线程之间<strong>相对独立</strong>，但可以共享应用程序的进程数据。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB622c668fd133939180976d83306cf859?method=download&shareKey=0b7e7c02902ad11f116a702fba92e0cf" alt="image"></p><ol start="3"><li><strong>如何理解JS的单线程</strong></li></ol><p>我们之所以称JS为单线程的语言，是因为它的执行引擎只有一个线程，并且不会在执行期间开启新的线程。而并非浏览器是单线程的。</p><p>单线程的应用程序具有以下的特点：</p><ul><li>易于学习和理解：所有代码都是按照顺序从上到下执行的</li><li>易于掌控程序：由于代码都按照顺序执行，不会出现中断，也没有共享资源的争夺问题，极大的降低了开发难度。</li><li>更加合理的利用计算机资源：创建新的线程和销毁线程都会耗费额外的CPU和内存资源，没有良好的线程设计，将导致程序运行效率低下。而单线程的应用不受此影响</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3850e8c6c8497752f09cf5c8548201f8?method=download&shareKey=e32b44945b947ec551a38fd8c9e013b7" alt="image"></p><ol start="4"><li><strong>JS如何处理多任务</strong></li></ol><p>任何一个程序在执行期间都可能会开启多个任务，比如：</p><p>1). 任务1：程序启动时开始进行一些操作<br>2). 任务2：开启一个计时器，每隔一段时间去做一些事<br>3). 任务3：监听按钮是否被点击，当按钮被点击后，去做一些事</p><p>由于JS的执行线程只有一个，因此，它通过异步的方式来解决这些任务</p><p>下面是单线程的异步和多线程的对比</p><p>多线程：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB29a15d2bcace2723bcf4470ca196260d?method=download&shareKey=2a34dfa74ba8e8e2497076c367397270" alt="image"></p><p>可以看到，如果以多线程的方式运行，会导致程序代码在某些时候会有重叠执行的情况出现，如果这些代码凑巧在使用共享数据，将难以控制最终的运行结果。</p><p>而使用异步的方式就解决了该问题：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB48ee74c5f6ce969426de1872177466c9?method=download&shareKey=4c7656a28702f351422279dcef3dcb27" alt="image"></p><p>可以看出，使用异步之后，所有的JS代码都在单个线程中执行，不会出现多个任务同时执行的情况，自然就不会出现资源争夺的问题。</p><ol start="5"><li><strong>同步代码 和 异步代码</strong></li></ol><p>同步代码：程序启动后，在JS执行线程上立即执行的任务代码</p><p>异步代码：收到宿主环境（浏览器）的其它线程通知，即将在JS执行线程上执行的代码，例如计时器回调函数中的代码，事件中的代码。JS中的异步代码往往放到一个函数中，该函数成为异步函数，或者描述为，该函数是异步的</p><ol start="6"><li><strong>执行栈</strong></li></ol><p>为了保证JS代码有序的执行，JS执行引擎使用执行栈来组织JS代码</p><p>每当调用一个函数时，都会在执行栈中创建一个执行上下文，上下文中提供了函数执行需要的环境，创建了上下文之后，再执行函数</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环是JS处理异步函数的具体方法</p><p>具体的做法是：</p><ol><li>执行 执行栈 中的代码</li><li>遇到一些特殊代码交给浏览器的其他线程处理</li><li>将执行栈中的代码全部执行完毕</li><li>从事件队列中取出第一个任务放入执行栈，然后重复第1步</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/WEBaf951fd4135c5c61f416c1c5b2be4fd9?method=download&shareKey=6b3fc46c45c93796213be24e4c7678ff" alt="iamge"></p><p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</p><ul><li>宏任务（队列）：macroTask，计时器结束的回调、事件回调、http回调等等绝大部分异步函数进入宏队列</li><li>微任务（队列）：microTask，Promise.then, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB302f38ba107e4f1c8aa9622f94e9fdb9?method=download&shareKey=1c4b31800f257ba1caf61b303e003eca" alt="image"></p><p>当执行栈清空时，JS引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事件循环-ignore&quot;&gt;&lt;a href=&quot;#事件循环-ignore&quot; class=&quot;headerlink&quot; title=&quot;事件循环 {ignore}&quot;&gt;&lt;/a&gt;事件循环 {ignore}&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型和原型链</title>
    <link href="http://yoursite.com/2020/05/18/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/05/18/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-05-18T07:19:37.000Z</published>
    <updated>2020-05-18T13:58:30.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ul><li>所有对象都是通过<code>new 函数</code>创建</li><li>所有的函数也是对象<ul><li>函数中可以有属性</li></ul></li><li>所有对象都是引用类型</li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>所有函数都有一个属性：prototype，称之为函数原型</p><p>默认情况下，prototype是一个普通的Object对象</p><p>默认情况下，prototype中有一个属性，constructor，它也是一个对象，它指向构造函数本身。</p><h2 id="隐式原型-proto"><a href="#隐式原型-proto" class="headerlink" title="隐式原型 proto"></a>隐式原型 <strong>proto</strong></h2><p>所有的对象都有一个属性：<code>__proto__</code>，称之为隐式原型</p><p>默认情况下，隐式原型指向创建该对象的函数的原型。</p><p>当访问一个对象的成员时：</p><ol><li><p>看该对象自身是否拥有该成员，如果有直接使用</p></li><li><p>在原型链中依次查找是否拥有该成员，如果有直接使用</p></li></ol><p>猴子补丁：在函数原型中加入成员，以增强起对象的功能，猴子补丁会导致原型污染，使用需谨慎。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>特殊点：</p><ol><li>Function的<strong>proto</strong>指向自身的prototype</li><li>Object的prototype的<strong>proto</strong>指向null</li></ol><h2 id="链条的全貌"><a href="#链条的全貌" class="headerlink" title="链条的全貌"></a>链条的全貌</h2><h2 id="原型和原型链-1"><a href="#原型和原型链-1" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ul><li><p>所有对象都是通过<code>new 函数</code>创建</p></li><li><p>所有的函数也是对象</p><ul><li>函数中可以有属性</li></ul></li><li><p>所有对象都是引用类型</p></li></ul><h2 id="原型-prototype-1"><a href="#原型-prototype-1" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>所有函数都有一个属性：prototype，称之为函数原型</p><p>默认情况下，prototype是一个普通的Object对象</p><p>默认情况下，prototype中有一个属性，constructor，它也是一个对象，它指向构造函数本身。</p><h2 id="隐式原型-proto-1"><a href="#隐式原型-proto-1" class="headerlink" title="隐式原型 proto"></a>隐式原型 <strong>proto</strong></h2><p>所有的对象都有一个属性：<code>__proto__</code>，称之为隐式原型</p><p>默认情况下，隐式原型指向创建该对象的函数的原型。</p><p>当访问一个对象的成员时：</p><ol><li><p>看该对象自身是否拥有该成员，如果有直接使用</p></li><li><p>在原型链中依次查找是否拥有该成员，如果有直接使用</p></li></ol><p>猴子补丁：在函数原型中加入成员，以增强起对象的功能，猴子补丁会导致原型污染，使用需谨慎。</p><h2 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h2><p>特殊点：</p><ol><li>Function的<strong>proto</strong>指向自身的prototype</li><li>Object的prototype的<strong>proto</strong>指向null</li></ol><h2 id="链条的全貌-1"><a href="#链条的全貌-1" class="headerlink" title="链条的全貌"></a>链条的全貌</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB194060970a726f4950296872423001af?method=download&shareKey=51be5efc6fe0a0fe1205fd4d58680393" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型和原型链&quot;&gt;&lt;a href=&quot;#原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;原型和原型链&quot;&gt;&lt;/a&gt;原型和原型链&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;所有对象都是通过&lt;code&gt;new 函数&lt;/code&gt;创建&lt;/li&gt;
&lt;li&gt;所有的函数也是对象
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>e的移动尺寸变化和div移动的尺寸变化</title>
    <link href="http://yoursite.com/2020/03/18/%E4%BA%8B%E4%BB%B6%E6%BA%90e%E5%92%8Cdiv%E7%9A%84%E5%B0%BA%E5%AF%B8%E5%8F%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/03/18/%E4%BA%8B%E4%BB%B6%E6%BA%90e%E5%92%8Cdiv%E7%9A%84%E5%B0%BA%E5%AF%B8%E5%8F%98%E5%8C%96/</id>
    <published>2020-03-18T08:16:42.000Z</published>
    <updated>2020-05-18T13:58:15.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于e-clientX-和-div的clientX等其他属性的变化"><a href="#关于e-clientX-和-div的clientX等其他属性的变化" class="headerlink" title="关于e.clientX 和 div的clientX等其他属性的变化!"></a>关于e.clientX 和 div的clientX等其他属性的变化!</h1><h4 id="遇到类似拖拽，滑动等效果时，总是有点分不清楚-判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下"><a href="#遇到类似拖拽，滑动等效果时，总是有点分不清楚-判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下" class="headerlink" title="遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下"></a>遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下</h4><a id="more"></a><p>对于点击事件源e来说</p><h3 id="clientX，clientY"><a href="#clientX，clientY" class="headerlink" title="clientX，clientY"></a>clientX，clientY</h3><p>点击位置距离当前可视区域的x，y坐标</p><h3 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX,pageY"></a>pageX,pageY</h3><p>对于整个页面来说，包括了被卷去的body部分的长度</p><h3 id="screenX，screenY"><a href="#screenX，screenY" class="headerlink" title="screenX，screenY"></a>screenX，screenY</h3><p>点击位置距离当前电脑屏幕边界的x，y坐标</p><h3 id="offsetX，offsetY"><a href="#offsetX，offsetY" class="headerlink" title="offsetX，offsetY"></a>offsetX，offsetY</h3><p>相对于带有定位的父盒子的x，y坐标</p><p>对于div来说</p><p><img src="https://i.loli.net/2020/03/18/L2BAZu7bdDnURhf.png" alt="尺寸1.png">))<br><img src="https://i.loli.net/2020/03/18/UdwDeolS2MfzxPh.png" alt="尺寸2.png"><br><img src="https://i.loli.net/2020/03/18/xY7n6vbyPh9akq8.png" alt="尺寸3.png"><br><img src="https://i.loli.net/2020/03/18/pOcIh5bjENtweF9.jpg" alt="尺寸4.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于e-clientX-和-div的clientX等其他属性的变化&quot;&gt;&lt;a href=&quot;#关于e-clientX-和-div的clientX等其他属性的变化&quot; class=&quot;headerlink&quot; title=&quot;关于e.clientX 和 div的clientX等其他属性的变化!&quot;&gt;&lt;/a&gt;关于e.clientX 和 div的clientX等其他属性的变化!&lt;/h1&gt;&lt;h4 id=&quot;遇到类似拖拽，滑动等效果时，总是有点分不清楚-判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下&quot;&gt;&lt;a href=&quot;#遇到类似拖拽，滑动等效果时，总是有点分不清楚-判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下&quot; class=&quot;headerlink&quot; title=&quot;遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下&quot;&gt;&lt;/a&gt;遇到类似拖拽，滑动等效果时，总是有点分不清楚 判断鼠标点击事件时的鼠标距离和作用div的距离，总结一下&lt;/h4&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>实现不设置宽高的盒子的居中</title>
    <link href="http://yoursite.com/2020/03/16/%E5%AE%9E%E7%8E%B0%E4%B8%8D%E8%AE%BE%E7%BD%AE%E5%AE%BD%E9%AB%98%E7%9A%84%E7%9B%92%E5%AD%90%E7%9A%84%E5%B1%85%E4%B8%AD/"/>
    <id>http://yoursite.com/2020/03/16/%E5%AE%9E%E7%8E%B0%E4%B8%8D%E8%AE%BE%E7%BD%AE%E5%AE%BD%E9%AB%98%E7%9A%84%E7%9B%92%E5%AD%90%E7%9A%84%E5%B1%85%E4%B8%AD/</id>
    <published>2020-03-16T06:54:56.000Z</published>
    <updated>2020-05-18T13:56:04.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3-transform"><a href="#CSS3-transform" class="headerlink" title="CSS3 transform"></a>CSS3 transform</h1><h3 id="有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现"><a href="#有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现" class="headerlink" title="有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现?"></a>有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现?</h3><a id="more"></a><ul><li>用css的transform中的translate可以实现,translate控制移动自身宽度的50%刚好实现垂直水平居中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 有两个div div2在div1中要实现垂直水平居中 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  *&#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0%;</span><br><span class="line">  &#125;</span><br><span class="line">  .div1 &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 500px;</span><br><span class="line">    background-color: green;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .div2 &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    max-width: 300px;</span><br><span class="line">    max-height: 300px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%,-50%)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;div2&quot;&gt;</span><br><span class="line">      daskjfhljsadhfkj</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3-transform&quot;&gt;&lt;a href=&quot;#CSS3-transform&quot; class=&quot;headerlink&quot; title=&quot;CSS3 transform&quot;&gt;&lt;/a&gt;CSS3 transform&lt;/h1&gt;&lt;h3 id=&quot;有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现&quot;&gt;&lt;a href=&quot;#有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现&quot; class=&quot;headerlink&quot; title=&quot;有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现?&quot;&gt;&lt;/a&gt;有两个div，子盒子相对父盒子绝对定位，要实现垂直水平居中，但子盒子没有给定宽度，这个时候要怎么实现?&lt;/h3&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://yoursite.com/2019/09/25/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2019/09/25/%E9%97%AD%E5%8C%85/</id>
    <published>2019-09-25T04:50:23.000Z</published>
    <updated>2020-05-18T13:54:42.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><a id="more"></a><ul><li><p>闭包就是指由权访问另一个函数作用域中的变量的函数。</p></li><li><p>创建闭包的常见的方式就是在一个函数内部创建另一个函数</p><p>当内部函数被保存到外部时，将会生成闭包；闭包会导致原有</p><p>作用链不释放，造成内存泄漏。</p></li></ul><p><strong><strong>内存泄漏可以理解为有用的内存因为原有作用链不释放，导致越来越少，就像是内存泄漏了一样</strong></strong></p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function a()&#123;</span><br><span class="line"></span><br><span class="line">        var num &#x3D; 100;</span><br><span class="line"></span><br><span class="line">        function b()&#123;</span><br><span class="line"></span><br><span class="line">            num ++;</span><br><span class="line"></span><br><span class="line">            console.log(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return b;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    var demo &#x3D; a();</span><br><span class="line"></span><br><span class="line">    demo(); &#x2F;&#x2F;101</span><br><span class="line"></span><br><span class="line">    demo(); &#x2F;&#x2F;100</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line"></span><br><span class="line">        function b() &#123;</span><br><span class="line"></span><br><span class="line">            var bbb &#x3D; 234;</span><br><span class="line"></span><br><span class="line">            document.write(aaa);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var aaa &#x3D; 123;</span><br><span class="line"></span><br><span class="line">        return b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        var glob &#x3D; 100;</span><br><span class="line"></span><br><span class="line">        var demo &#x3D; a();</span><br><span class="line"></span><br><span class="line">        demo();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有对局部和全局变量有一个模糊的印象</span><br></pre></td></tr></table></figure> <!-- more --><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li><p>实现公有变量</p><p>  eg:函数累加器</p></li><li><p>可以做缓存</p><p>  eg:eater</p></li><li><p>可以实现封装，属性私有化。</p><p>  eg: Person();</p></li><li><p>模块化开发，防止污染全局变量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var name &#x3D; &#39;bcd&#39;;</span><br><span class="line"></span><br><span class="line">        var init &#x3D; (function ()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            var name &#x3D; &#39;abc&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            function callName()&#123;</span><br><span class="line"></span><br><span class="line">                console.log(name);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return function()&#123;</span><br><span class="line"></span><br><span class="line">                callName();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;())</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;运行后的结果为 abc</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这就是用闭包实现变量的私有化，函数中的变量在外部调用不会污染全局变量</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;以后用于模块化开发 防止污染全局变量</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES笔记</title>
    <link href="http://yoursite.com/2019/09/25/ES%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/25/ES%E7%AC%94%E8%AE%B0/</id>
    <published>2019-09-25T03:38:20.000Z</published>
    <updated>2020-05-18T13:53:54.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><a id="more"></a><p>动态语言 数据类型取决于取值<br>JS中分为七种内置类型，七种内置类型分为两大类型，基本类型和对象<br>基本类型有六种：null,undefined,boolean,number,string,symbol<br>NaN也属于number，并且NaN并不等于自身</p><ul><li>类型转换<br>对象在转换基本数据类型，首先会调用valueOf然后调用toString。并且这两个方法你是可以重写的<br>let a = {<pre><code>valueOf(){    return 0}</code></pre>}<br>当然你也可以重写Symbol.toPrimitive,该方法在转基本类型时调用优先级最高<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;1&#39;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 + a &#x2F;&#x2F; &#x3D;&gt; 3</span><br><span class="line">&#39;1&#39; + a &#x2F;&#x2F; &#x3D;&gt; &#39;12&#39;</span><br></pre></td></tr></table></figure></li></ul><p>​        </p><h2 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h2><p>var a = 1 / 0 ;</p><p>// Infinity Number</p><p>var num = 0 / 0;</p><p>// NaN Not a Number</p><ul><li>四则运算符<br>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且假发运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。</li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><strong>&amp;&amp; || ！</strong></p><p>&amp;&amp;<br>先看第一表达式转换成布尔值的结果，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，<br>然后如果只有两个表达式的话，只要看到第二个表达式，就可以返回该表达式的值了。</p><p>转换成 与 的抽象概念来进行值的运算</p><p>如果前面是真 那么后面不管是什么都输出后面，后面是真都为真，输出后面也为真，后面是假即为假，即输出后面的假的</p><p>undefined，null，NaN，“”，0，false ==&gt; false;</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>   函数声明整体提升<br>   变量 声明提升<br>   <strong>预编译发生在函数执行的前一刻</strong></p><ol><li>创建AO对象 </li><li>找形参和变量声明，将变量和形参名作为AO属性名，值为undefined</li><li>将实参值和形参统一</li><li>在函数体里面找函数声明，值赋予函数体</li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><pre><code>scope chain --&gt; 0:AO            --&gt; 1:GO</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 100;</span><br><span class="line">function demo(e) &#123;</span><br><span class="line">    function e() &#123; &#125;</span><br><span class="line">    arguments[0] &#x3D; 2;</span><br><span class="line">    document.write(e); &#x2F;&#x2F; 2</span><br><span class="line">    if (a) &#123;</span><br><span class="line">        var b &#x3D; 123;</span><br><span class="line">        function c() &#123;</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var c;</span><br><span class="line">    a &#x3D; 10;</span><br><span class="line">    var a;</span><br><span class="line">    document.write(b); &#x2F;&#x2F;undefined</span><br><span class="line">    f &#x3D; 123;</span><br><span class="line">    document.write(c);&#x2F;&#x2F; undefined</span><br><span class="line">    document.write(a);&#x2F;&#x2F;10</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br><span class="line">demo(1);</span><br><span class="line">document.write(a); &#x2F;&#x2F;100</span><br><span class="line">document.write(f); &#x2F;&#x2F;123</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>闭包就是指由权访问另一个函数作用域中的变量的函数。</li><li>创建闭包的常见的方式就是在一个函数内部创建另一个函数<br>当内部函数被保存到外部时，将会生成闭包；闭包会导致原有<br>作用链不释放，造成内存泄漏。</li></ul><p><strong>内存泄漏可以理解为有用的内存因为原有作用链不释放，导致越来越少，就像是内存泄漏了一样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">        var num &#x3D; 100;</span><br><span class="line">        function b()&#123;</span><br><span class="line">            num ++;</span><br><span class="line">            console.log(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    var demo &#x3D; a();</span><br><span class="line">    demo(); &#x2F;&#x2F;101</span><br><span class="line">    demo(); &#x2F;&#x2F;100</span><br></pre></td></tr></table></figure><p><code>这里有对局部和全局变量有一个模糊的印象</code></p><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li>实现公有变量<br>  eg:函数累加器</li><li>可以做缓存<br>  eg:eater</li><li>可以实现封装，属性私有化。<br>  eg: Person();</li><li>模块化开发，防止污染全局变量</li></ul><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><ul><li>立即执行函数，执行完就会被销毁/释放，只被执行一次</li><li>针对初始化功能的函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>能被执行符号执行的表达式就是立即执行函数/被忽视函数名</p><ul><li><ul><li>！() 都可以将函数变成表达式</li></ul></li><li><p>function(){</p><p>}();<br>(function(){</p><p>}())</p></li></ul><p>(function(){</p><p>})();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; function()&#123;</span><br><span class="line">    console.log(&#39;a&#39;);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h3><p><strong>JS的对象创建不同于Java，c++，不需要类来定义属性和方法，直接在对象上定义属性和方法，更贴近面向对象，把对象当成一个真的的事物</strong></p><ol><li><p>var obj = {}   对象字面量/对象直接量</p></li><li><p>构造函数</p><ul><li><p>系统自带的构造函数 Object() Array() Number()</p><p>var obj = new Object();</p></li><li><p>自定义构造函数<br>//大驼峰式命名规则</p><p>function Person(){</p><p>}</p><p>var person1 = new Person();</p></li></ul><p> <strong>就相当于创建了一个空对象</strong></p></li></ol><h3 id="构造函数内部原理"><a href="#构造函数内部原理" class="headerlink" title="构造函数内部原理"></a>构造函数内部原理</h3><ol><li>在函数体的最前面隐式的加上this = {}</li><li>执行this.xxx = xxx;</li><li>隐式的返回this<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,sex)&#123;</span><br><span class="line">    &#x2F;&#x2F;var this &#x3D; &#123;&#125;  一个空对象</span><br><span class="line">    this.name &#x3D; name; &#x2F;&#x2F; 往this里面加，name : &quot;xx&quot;,</span><br><span class="line">    this.age  &#x3D; age;</span><br><span class="line">    this.sex  &#x3D; sex;</span><br><span class="line">    &#x2F;&#x2F;return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var person1 &#x3D; new Person(&#39;zhangsan&#39;,18,&#39;man&#39;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol><li>定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。<strong>原型也是对象。</strong></li><li>利用原型特点和概念，可以提取共有属性</li><li>对象如何查看原型 — &gt; 隐式属性 <em>proto</em></li><li>对象如何查看对象的构造函数 — &gt; constructor</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype  --原型</span><br><span class="line">Person.prototype &#x3D; &#123;&#125;  是祖先</span><br><span class="line">Person.prototype.name &#x3D; &quot;hehe&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">&#x2F;&#x2F;新建的对象可以继承Person原型的属性和方法</span><br></pre></td></tr></table></figure><h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h2><ul><li>借用构造函数<br>作用，改变this指向。<br>区别，后面传的参数形式不同<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex)&#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">            this.sex &#x3D; sex;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var person &#x3D; new Person(&#39;li&#39;, 18 , &#39;man&#39;);</span><br><span class="line"></span><br><span class="line">        var obj &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        Person.call(obj,&#39;tang&#39;,20,&#39;famale&#39;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;call 借用别人的方法实现自己的功能</span><br><span class="line">        输出obj</span><br><span class="line">        obj</span><br><span class="line">        &#123;name: &quot;tang&quot;, age: 20, sex: &quot;famale&quot;&#125;</span><br><span class="line">        person</span><br><span class="line">        Person &#123;name: &quot;li&quot;, age: 18, sex: &quot;man&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">            this.sex &#x3D; sex;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        function Student(name, age, sex, tel, grade) &#123;</span><br><span class="line">            Person.call(this, name, age, sex);          &#x2F;&#x2F;这样来调用Person的方法</span><br><span class="line">            this.tel &#x3D; tel;</span><br><span class="line">            this.grade &#x3D; grade;</span><br><span class="line">        &#125;</span><br><span class="line">        var student &#x3D; new Student(&#39;tang&#39;, 18, &#39;female&#39;, 123, 99);</span><br></pre></td></tr></table></figure>call 需要把实参按照形参的个数传进去<br>apply 需要传一个arguments的形式<br>两者就是传参的形式不同<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.apply(this,[name,age,se]);</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol><li>传统形式<br> 过多的继承了没用的属性</li><li>借用构造函数<br> 不能继承借用构造函数的原型<br> 每次构造函数都要多走一个函数</li><li>共享原型<br> 不能随便改动自己的原型</li><li>圣杯模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">现在 - 圣杯模式 在共享原型基础上</span><br><span class="line">function inherit(Target, Origin)&#123;</span><br><span class="line">            function F()&#123;&#125;</span><br><span class="line">            F.prototype &#x3D; Origin.prototype;</span><br><span class="line">            Target.prototype &#x3D; new F();</span><br><span class="line">            Target.prototype.constuctor &#x3D; Target;</span><br><span class="line">            Target.prototype.uber &#x3D; Origin.prototype;  &#x2F;&#x2F;继承谁</span><br><span class="line">        &#125;</span><br><span class="line">        Father.prototype.lastName &#x3D; &#39;li&#39;;</span><br><span class="line">        function Father()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        function Son()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inherit(Son, Father);</span><br><span class="line">        var son &#x3D; new Son();</span><br><span class="line">        var father &#x3D; new Father();</span><br><span class="line"></span><br><span class="line">        此时Son这个构造函数能够继承原来Father的原型的属性，而且自己能够更改原型属性的同时，不会影响到father的原型属性。</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>定义一个命名空间</p><p>管理变量，防止污染全局，适用于模块化开发</p><h2 id="查看属性，对象枚举"><a href="#查看属性，对象枚举" class="headerlink" title="查看属性，对象枚举"></a>查看属性，对象枚举</h2><p>for  in 遍历对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">           name : &#39;ljh&#39;,</span><br><span class="line">           age : 123,</span><br><span class="line">           sex : &#39;male&#39;,</span><br><span class="line">           height : 180,</span><br><span class="line">           weight : 75</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for(var prop in obj)&#123;</span><br><span class="line">           console.log(prop + &quot; &quot; + typeof(prop));</span><br><span class="line">           &#x2F;&#x2F;  下面结果为5个undefined，因为要想得到属性值，有了属性名后，</span><br><span class="line">           &#x2F;&#x2F; obj.prop --&gt;obj[&#39;prop&#39;]这时的prop就是字符串属性名，obj没有prop属性 所以返回undefined</span><br><span class="line">           &#x2F;&#x2F; conslole.log(obj.prop);    </span><br><span class="line">           console.log(obj[prop]);  &#x2F;&#x2F;属性值</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">            name: &#39;ljh&#39;,</span><br><span class="line">            age: 123,</span><br><span class="line">            sex: &#39;male&#39;,</span><br><span class="line">            height: 180,</span><br><span class="line">            weight: 75,</span><br><span class="line">            __proto__: &#39;deng&#39;  &#x2F;&#x2F;加上原型的属性，下面依然会打印</span><br><span class="line">        &#125;</span><br><span class="line">        for (var prop in obj) &#123;</span><br><span class="line">            &#x2F;&#x2F;加上hasOwnProperty方法判断prop是否为本身属性</span><br><span class="line">            if (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">                console.log(obj[prop]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>in 也可以判断属性是否为对象的，但是会将父类的也算进去</li></ul><ul><li>注意使用时要用字符串，不然会被系统当成变量，属性名是字符串</li></ul><p>‘height’ in obj   true<br>‘lastName’ in obj  true</p><p><strong>instanceof</strong></p><p>A instanceof B</p><p>看A对象的原型链上有没有 B的原型</p><p>A对象是不是B构造函数构造出来的</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ol><li>函数预编译过程 this —&gt; window</li><li>全局作用域里 this —&gt; window</li><li>call/apply 可以改变函数运行时this指向</li><li>obj.func();   func()里面的this指向obj) 谁调用this指向谁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;this 面试题</span><br><span class="line">var name &#x3D; &#39;222&#39;;</span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">    name : &#39;111&#39;,</span><br><span class="line">    say : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">var fun &#x3D; a.say;  &#x2F;&#x2F;222 把a对象中的函数拿出来在全局执行 所有是全局的name</span><br><span class="line">fun();  </span><br><span class="line">a.say(); &#x2F;&#x2F;&#x2F;111</span><br><span class="line">var b &#x3D; &#123;</span><br><span class="line">    name : &quot;333&quot;,</span><br><span class="line">    say : function (fun)&#123;</span><br><span class="line">        &#x2F;&#x2F;this --&gt; b 这里面的this还是指向b，但是下面函数执行时直接执行，没有人调用，执行就是预编译环境，就是windows</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">b.say(a.say);   &#x2F;&#x2F;222  a.say当成一个参数就是一个函数 然后在b里面被执行</span><br><span class="line">b.say &#x3D; a.say;</span><br><span class="line">b.say(); &#x2F;&#x2F;333</span><br></pre></td></tr></table></figure><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul><li>arguments.callee 等于函数自身的引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    console.log(argumens.callee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; (function (n)&#123;</span><br><span class="line">    if(n &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return n * arguments.callee(n - 1);</span><br><span class="line">&#125;(10))</span><br></pre></td></tr></table></figure><ul><li>caller 指函数被调用被执行时的环境时哪个环境</li></ul><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><ul><li>浅层克隆<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name : &#39;tom&#39;,</span><br><span class="line">    age : 18,</span><br><span class="line">    sex : &#39;male&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var target &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">function clone(origin, target)&#123;</span><br><span class="line">    var target &#x3D; target || &#123;&#125;;</span><br><span class="line">    for(var prop in origin)&#123;</span><br><span class="line">        target[prop] &#x3D; oringin[prop];</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;但是当对象有引用值(数组)时，改变target中的引用值，origin中的引用值也会改变</span><br></pre></td></tr></table></figure></li><li>深度克隆<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;深度克隆</span><br><span class="line">&#x2F;&#x2F;遇到引用值时需要判断，何种引用值，新建一个引用，将原来的值填入</span><br><span class="line">&#x2F;&#x2F;遍历对象 for(var prop in obj)</span><br><span class="line">&#x2F;&#x2F;1.判断是否原始值(基本数据类型)  用typeof 判断是否object</span><br><span class="line">&#x2F;* 2.判断时数组还是对象 &#123;</span><br><span class="line">    istanceof toString constructor</span><br><span class="line">&#125; *&#x2F;</span><br><span class="line">&#x2F;&#x2F;3.建立相应的数组或对象</span><br><span class="line">&#x2F;&#x2F;4.递归</span><br><span class="line">    var obj &#x3D; &#123;</span><br><span class="line">        name: &#39;abc&#39;,</span><br><span class="line">        age: 23,</span><br><span class="line">        card: [&#39;visa&#39;, &#39;master&#39;],</span><br><span class="line">        wife: &#123;</span><br><span class="line">            name: &#39;bcd&#39;,</span><br><span class="line">            son: &#123;</span><br><span class="line">                name: &#39;aaa&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var obj1 &#x3D; &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    function deepClone(Origin, target) &#123;</span><br><span class="line">        var target &#x3D; target || &#123;&#125;,  &#x2F;&#x2F;容错 如果有就有 没有就新建一个</span><br><span class="line">            toStr &#x3D; Object.prototype.toString,</span><br><span class="line">            arrStr &#x3D; &quot;[object Array]&quot;;      &#x2F;&#x2F;两者比对判断是否数组</span><br><span class="line">        for (var prop in origin) &#123;</span><br><span class="line">            &#x2F;&#x2F;加上hasOwnProperty方法判断prop是否为本身属性 不拿原型链上的值</span><br><span class="line">            if (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">                if (typeof (origin[prop]) &#x3D;&#x3D; &#39;object&#39; &amp;&amp; origin[prop]!&#x3D;&#x3D; &#39;null&#39;) &#123;</span><br><span class="line">                    &#x2F;&#x2F;判断引用值是否为数组 建立新数组或对象</span><br><span class="line">                    if (toStr.call(origin[prop]) &#x3D;&#x3D; arrStr) &#123;</span><br><span class="line">                        target[prop] &#x3D; [];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        target[prop] &#x3D; &#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    deepClone(origin[prop], target[prop]);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    target[prop] &#x3D; origin[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>封装 type方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;封装一个typeof函数</span><br><span class="line">        &#x2F;&#x2F;1. 分两类 原始值 引用值</span><br><span class="line">        &#x2F;&#x2F;2. 区分引用值</span><br><span class="line"></span><br><span class="line">        function type(target) &#123;</span><br><span class="line">            var ret &#x3D; typeof(target);</span><br><span class="line">            var template &#x3D; &#123;</span><br><span class="line">                &quot;[object Array]&quot;: &#39;array&#39;,</span><br><span class="line">                &quot;[object Object]&quot;: &#39;object&#39;,</span><br><span class="line">                &quot;[object Number]&quot;: &#39;number - object&#39;,</span><br><span class="line">                &quot;[object Boolean]&quot;: &#39;boolean - object&#39;,</span><br><span class="line">                &quot;[object String]&quot;: &#39;string - object&#39;,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return &#39;null&#39;;</span><br><span class="line">            &#125; else if (ret &#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">                var str &#x3D; Object.prototype.toString.call(target);</span><br><span class="line">                return template[str];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3></li></ul><p>条件判断 ? 是 : 否 并且会返回值</p><p>var num = 1 &gt; 0 ? 2 + 2 : 1 + 1; //1大于0吗 是 返回2 + 2 不是 返回 1 + 1</p><p>var num = 1 &gt; 0 ? (“10” &gt; “9” ? 1 : 0) : 2;<br>字符串比对 比对ascii码 10 小于 9 返回0</p><ul><li>上面深度克隆里可以用三目运算符稍微简化一些if</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p>在js中就是一种特殊的对象</p><p>两种方式定义数组</p><p>var arr = [];<br>var arr = new Array();</p><ul><li>数组常用的几个方法，</li><li>改变原数组<br>push,pop,shift,unshift,sort,reverse,splice</li></ul><p>arr.splice(从第几位开始，截取多少的长度，在切口处添加新的数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1,2,3,5];</span><br><span class="line">arr.splice(3,0,4);</span><br><span class="line">&#x2F;&#x2F;arr&#x3D;[1,2,3,4,5p]</span><br></pre></td></tr></table></figure><p>按照ascii码排序<br>sort 给数组排序 升序<br>arr.sort().reverse() 变降序了</p><p>系统提供重写sort方法 内部原理 冒泡排序</p><ol><li>必须要有两个形参</li><li>看返回值  <pre><code>1. 当返回值为负数时，那么前面的数放在前面2. 为整数，那么后面的数在前3. 为0 不动</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [20,2,10,23,4,34,5,6];</span><br><span class="line"></span><br><span class="line">    arr.sort(function (a,b))&#123;</span><br><span class="line"></span><br><span class="line">        &lt;!-- if(a &gt; b)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; --&gt;</span><br><span class="line"></span><br><span class="line">        return a - b;  &#x2F;&#x2F;升序</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给一个有序的数组，乱序</span><br><span class="line">var arr &#x3D; [1,2,3,4,5,6];</span><br><span class="line">arr.sort(function()&#123;</span><br><span class="line">    return Math.random() - 0.5;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><ul><li>不改变原数组<br>concat,join–&gt;split,toString,slice</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;数组去重</span><br><span class="line">        &#x2F;&#x2F;要求在原型链上编程</span><br><span class="line">        &#x2F;* </span><br><span class="line">            该方法利用对象的特性来去重，对象中属性名不可能会相同，</span><br><span class="line">            将数组中每一位取出来，放到对象中当属性名，最开始相同的数组值放对象里</span><br><span class="line">            给它一个属性值，下面相同的数组值时就无法进入对象，再把对象的属性名push</span><br><span class="line">            到一个空的数组中，返回数组</span><br><span class="line">            </span><br><span class="line">         *&#x2F;</span><br><span class="line">        var arr &#x3D; [1,1,2,2,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;];</span><br><span class="line"></span><br><span class="line">        Array.prototype.unique &#x3D; function () &#123;</span><br><span class="line">            var temp &#x3D; &#123;&#125;;</span><br><span class="line">            var arr &#x3D; [],</span><br><span class="line">                len &#x3D; this.length;</span><br><span class="line">            for(i &#x3D; 0;i &lt; len; i ++)&#123;</span><br><span class="line">                if(!temp[this[i]])&#123;     &#x2F;&#x2F;原来没有值的时候就是undefined，!undefined就是true</span><br><span class="line">                    temp[this[i]] &#x3D; &#39;6&#39;;</span><br><span class="line">                    arr.push(this[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><ol><li>可以利用属性名模拟数组的特性</li><li>可以动态的增长length属性</li><li>如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test(1,2,3,4,5);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;输出 [1,2,3,4,5] 但不是数组 类数组</span><br><span class="line">    &#x2F;&#x2F;类数组 对象</span><br><span class="line">    var obj &#x3D; &#123;</span><br><span class="line">        &quot;0&quot; : &#39;a&#39;,</span><br><span class="line">        &quot;1&quot; : &#39;b&#39;,</span><br><span class="line">        &quot;2&quot; : &#39;c&#39;,</span><br><span class="line">        &quot;length&quot; : 3,</span><br><span class="line">        &quot;push&quot; : Array.prototype.push,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;属性要为索引(数字)属性，必须有length属性，最好加上push</span><br><span class="line">    &#x2F;&#x2F;length决定在哪一位上push</span><br><span class="line">    &#x2F;&#x2F; Array.prototype.push &#x3D; function (target)&#123;</span><br><span class="line">    &#x2F;&#x2F;     obj[obj.length] &#x3D; target;</span><br><span class="line">    &#x2F;&#x2F;     obj.length ++;</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><p>在try里面发生错误，不会执行错误后的try里的代码，try外的继续，</p><p>try{}catch(e) {}finally{}<br>Error.name的六种值对应的信息：</p><ol><li>EvalError：eval()的使用与定义不一致 </li><li>RangeError：数值越界 </li><li>ReferenceError：非法或不能识别的引用数值 </li><li>SyntaxError：发生语法解析错误 </li><li>TypeError：操作数类型错误 </li><li>URIError：URI处理函数使用不当</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
